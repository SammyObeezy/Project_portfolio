import React from 'react';
export declare type Reducer<S extends object> = (arg0: S, ...args: any[]) => S;
export declare type Reducers<P, S extends object> = {
    [K in keyof P]?: Reducer<S> | Reducers<P[K], S> | Reducers<P[K], any>;
};
export declare type Selector<S> = (arg0: S) => any;
export declare type Selectors<P, S extends object> = {
    [K in keyof P]?: (arg0: S) => any;
};
interface IStateOptions<S extends object> {
    getState: () => S;
    setState: (arg0: S) => void;
}
interface IBoundContext<P, S extends object> {
    getPropReplaceReducers(props: P): {} & S & P;
    getProps(props: P): {} & S & P;
}
interface IBuildHybridComponentOptions<P = {}, S extends object = {}> {
    replaceEvents?: boolean;
    reducers?: Reducers<P, S>;
    selectors?: Selectors<P, S>;
}
export declare function getDeepPaths(obj?: {
    [k: string]: any;
} | null, path?: string[]): string[][];
export declare function isPlainObjectOrEsModule(obj: any): boolean;
/**
    Recursively removes function type properties from obj
 */
export declare function omitFunctionPropsDeep<P>(obj?: object | P | null): {
    [k: string]: any;
};
export declare function bindReducerToState<P, S extends object>(reducerFunction: Reducer<S>, { getState, setState }: IStateOptions<S>, path?: string[]): ((...args: any[]) => void) & {
    path: string[];
};
export declare function bindReducersToState<P, S extends object>(reducers: Reducers<P, S>, { getState, setState }: IStateOptions<S>): {};
export declare function getStatefulPropsContext<P, S extends object>(reducers: Reducers<P, S>, { getState, setState }: IStateOptions<S>): IBoundContext<P, S>;
/**
 * reduceSelectors
 *
 * Generates a root selector from a tree of selectors
 * @param {Object} selectors - a tree of selectors
 * @returns {function} root selector that when called with state, calls each of
 * the selectors in the tree with the state local to that selector.
 *
 * This function is memoized because it's recursive, and we want it to reuse
 * the functions created in the recursive reduce because those functions are
 * also memoized (reselect selectors are memoized with a cache of 1) and we want
 * to maintain their caches.
 *
 * TODO: the types suck on this function but we spent a couple hours trying to
 * get them to work and we couldn't figure out how to get generics to pass
 * through _.memoize correctly. ¯\_(ツ)_/¯
 */
export declare const reduceSelectors: any;
export declare function safeMerge(objValue: any, srcValue: any): any[] | React.ReactElement<unknown, string | React.JSXElementConstructor<any>> | undefined;
export declare function buildHybridComponent(baseComponent: any, { replaceEvents, // if true, function props replace the existing reducers, else they are invoked *after* state reducer returns
reducers, selectors, }?: {
    replaceEvents?: boolean | undefined;
    reducers?: any;
    selectors?: any;
}): any;
export interface IHybridComponent<P, S extends object> {
    reducers: Reducers<P, S>;
    selectors: Selectors<P, S>;
    peekDefaultProps: {
        [key: string]: any;
    };
}
export declare function buildModernHybridComponent<P extends object = {}, S extends object = {}, BaseType extends object = {}>(BaseComponent: React.ComponentType<P>, { replaceEvents, reducers, selectors, }: IBuildHybridComponentOptions<P, S>): BaseType & IHybridComponent<P, S>;
export {};
//# sourceMappingURL=state-management.d.ts.map