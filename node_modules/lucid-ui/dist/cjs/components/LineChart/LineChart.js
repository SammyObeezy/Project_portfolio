"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __importStar(require("lodash"));
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var d3Scale = __importStar(require("d3-scale"));
var d3TimeFormat = __importStar(require("d3-time-format"));
var style_helpers_1 = require("../../util/style-helpers");
var component_types_1 = require("../../util/component-types");
var chart_helpers_1 = require("../../util/chart-helpers");
var chartConstants = __importStar(require("../../constants/charts"));
var Axis_1 = __importDefault(require("../Axis/Axis"));
var AxisLabel_1 = __importDefault(require("../AxisLabel/AxisLabel"));
var Legend_1 = __importDefault(require("../Legend/Legend"));
var Lines_1 = __importDefault(require("../Lines/Lines"));
var Points_1 = __importDefault(require("../Points/Points"));
var ToolTip_1 = require("../ToolTip/ToolTip");
var ContextMenu_1 = __importDefault(require("../ContextMenu/ContextMenu"));
var EmptyStateWrapper_1 = __importDefault(require("../EmptyStateWrapper/EmptyStateWrapper"));
var cx = style_helpers_1.lucidClassNames.bind('&-LineChart');
var arrayOf = prop_types_1.default.arrayOf, func = prop_types_1.default.func, instanceOf = prop_types_1.default.instanceOf, number = prop_types_1.default.number, object = prop_types_1.default.object, shape = prop_types_1.default.shape, string = prop_types_1.default.string, bool = prop_types_1.default.bool, oneOfType = prop_types_1.default.oneOfType, oneOf = prop_types_1.default.oneOf;
/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */
var nonPassThroughs = [
    'className',
    'height',
    'width',
    'margin',
    'data',
    'legend',
    'isLoading',
    'hasToolTips',
    'hasLegend',
    'palette',
    'colorMap',
    'xAxisField',
    'xAxisMin',
    'xAxisMax',
    'xAxisFormatter',
    'xAxisTooltipFormatter',
    'xAxisTickCount',
    'xAxisTicks',
    'xAxisTitle',
    'xAxisTitleColor',
    'xAxisTextOrientation',
    'yAxisFields',
    'yAxisMin',
    'yAxisMax',
    'yAxisFormatter',
    'yAxisIsStacked',
    'yAxisHasPoints',
    'yAxisTickCount',
    'yAxisTitle',
    'yAxisTitleColor',
    'yAxisTooltipFormatter',
    'yAxisTooltipDataFormatter',
    'yAxisColorOffset',
    'y2AxisFields',
    'y2AxisMin',
    'y2AxisMax',
    'y2AxisFormatter',
    'y2AxisTooltipDataFormatter',
    'y2AxisIsStacked',
    'y2AxisHasPoints',
    'y2AxisTickCount',
    'y2AxisTitle',
    'y2AxisTitleColor',
    'y2AxisColorOffset',
    'yAxisTextOrientation',
    'callbackId',
    'initialState',
];
var LineChart = /** @class */ (function (_super) {
    __extends(LineChart, _super);
    function LineChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isHovering: false,
            mouseX: undefined,
        };
        _this.handleToolTipHoverZone = function (_a, xPoints) {
            var clientX = _a.clientX, target = _a.target;
            var mouseX = (0, chart_helpers_1.nearest)(xPoints, clientX - target.getBoundingClientRect().left);
            if (!_this.state.isHovering || _this.state.mouseX !== mouseX) {
                _this.setState({
                    isHovering: true,
                    mouseX: (0, chart_helpers_1.nearest)(xPoints, clientX - target.getBoundingClientRect().left),
                });
            }
        };
        _this.renderY2Axis = function (xScale, y2Scale, y2AxisFinalFormatter, margin) {
            var _a = _this.props, y2AxisFields = _a.y2AxisFields, yAxisFields = _a.yAxisFields, y2AxisTickCount = _a.y2AxisTickCount, y2AxisTitle = _a.y2AxisTitle, y2AxisTitleColor = _a.y2AxisTitleColor, palette = _a.palette, xAxisField = _a.xAxisField, y2AxisMax = _a.y2AxisMax, data = _a.data, y2AxisIsStacked = _a.y2AxisIsStacked, y2AxisColorOffset = _a.y2AxisColorOffset, colorMap = _a.colorMap, y2AxisHasPoints = _a.y2AxisHasPoints;
            /* y2 axis */
            var axis = y2AxisFields ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left + innerWidth, ", ").concat(margin.top, ")") },
                react_1.default.createElement(Axis_1.default, { orient: 'right', scale: y2Scale, tickFormat: y2AxisFinalFormatter, tickCount: y2AxisTickCount }))) : null;
            /* y2 axis title */
            var axisTitle = y2AxisTitle ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left + innerWidth, ", ").concat(margin.top, ")") },
                react_1.default.createElement(AxisLabel_1.default, { orient: 'right', width: margin.right, height: innerHeight, label: y2AxisTitle, color: lodash_1.default.isString(y2AxisTitleColor)
                        ? y2AxisTitleColor
                        : palette[y2AxisTitleColor % palette.length] }))) : null;
            var axisLines = y2AxisFields ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                react_1.default.createElement(Lines_1.default, { xScale: xScale, yScale: y2Scale, xField: xAxisField, yFields: y2AxisFields, yStackedMax: y2AxisMax, data: data || {}, isStacked: y2AxisIsStacked, colorOffset: y2AxisColorOffset + yAxisFields.length, colorMap: colorMap, palette: palette }))) : null;
            var axisPoints = y2AxisFields && y2AxisHasPoints ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                react_1.default.createElement(Points_1.default, { xScale: xScale, yScale: y2Scale, xField: xAxisField, yFields: y2AxisFields, yStackedMax: y2AxisMax, data: data || {}, isStacked: y2AxisIsStacked, colorOffset: y2AxisColorOffset + yAxisFields.length, colorMap: colorMap, palette: palette }))) : null;
            return {
                title: axisTitle,
                lines: axisLines,
                points: axisPoints,
                axis: axis,
            };
        };
        return _this;
    }
    LineChart.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, height = _a.height, width = _a.width, marginOriginal = _a.margin, data = _a.data, legend = _a.legend, isLoading = _a.isLoading, hasToolTips = _a.hasToolTips, hasLegend = _a.hasLegend, palette = _a.palette, colorMap = _a.colorMap, xAxisField = _a.xAxisField, xAxisTickCount = _a.xAxisTickCount, xAxisTicks = _a.xAxisTicks, xAxisTitle = _a.xAxisTitle, xAxisTitleColor = _a.xAxisTitleColor, xAxisFormatter = _a.xAxisFormatter, xAxisTooltipFormatter = _a.xAxisTooltipFormatter, _b = _a.xAxisMin, xAxisMin = _b === void 0 ? (0, chart_helpers_1.minByFields)(data, xAxisField) : _b, _c = _a.xAxisMax, xAxisMax = _c === void 0 ? (0, chart_helpers_1.maxByFields)(data, xAxisField) : _c, xAxisTextOrientation = _a.xAxisTextOrientation, yAxisFields = _a.yAxisFields, yAxisFormatter = _a.yAxisFormatter, yAxisHasPoints = _a.yAxisHasPoints, yAxisIsStacked = _a.yAxisIsStacked, yAxisTickCount = _a.yAxisTickCount, yAxisTitle = _a.yAxisTitle, yAxisTitleColor = _a.yAxisTitleColor, yAxisMin = _a.yAxisMin, yAxisTooltipFormatter = _a.yAxisTooltipFormatter, yAxisTooltipDataFormatter = _a.yAxisTooltipDataFormatter, _d = _a.yAxisMax, yAxisMax = _d === void 0 ? (yAxisIsStacked
            ? (0, chart_helpers_1.maxByFieldsStacked)(data, yAxisFields)
            : (0, chart_helpers_1.maxByFields)(data, yAxisFields)) : _d, yAxisColorOffset = _a.yAxisColorOffset, y2AxisFields = _a.y2AxisFields, y2AxisFormatter = _a.y2AxisFormatter, y2AxisTooltipDataFormatter = _a.y2AxisTooltipDataFormatter, y2AxisHasPoints = _a.y2AxisHasPoints, y2AxisIsStacked = _a.y2AxisIsStacked, y2AxisMin = _a.y2AxisMin, _e = _a.y2AxisMax, y2AxisMax = _e === void 0 ? (y2AxisFields && y2AxisIsStacked
            ? (0, chart_helpers_1.maxByFieldsStacked)(data, y2AxisFields)
            : (0, chart_helpers_1.maxByFields)(data, y2AxisFields)) : _e, y2AxisColorOffset = _a.y2AxisColorOffset, yAxisTextOrientation = _a.yAxisTextOrientation, passThroughs = __rest(_a, ["className", "height", "width", "margin", "data", "legend", "isLoading", "hasToolTips", "hasLegend", "palette", "colorMap", "xAxisField", "xAxisTickCount", "xAxisTicks", "xAxisTitle", "xAxisTitleColor", "xAxisFormatter", "xAxisTooltipFormatter", "xAxisMin", "xAxisMax", "xAxisTextOrientation", "yAxisFields", "yAxisFormatter", "yAxisHasPoints", "yAxisIsStacked", "yAxisTickCount", "yAxisTitle", "yAxisTitleColor", "yAxisMin", "yAxisTooltipFormatter", "yAxisTooltipDataFormatter", "yAxisMax", "yAxisColorOffset", "y2AxisFields", "y2AxisFormatter", "y2AxisTooltipDataFormatter", "y2AxisHasPoints", "y2AxisIsStacked", "y2AxisMin", "y2AxisMax", "y2AxisColorOffset", "yAxisTextOrientation"]);
        var _f = this.state, isHovering = _f.isHovering, mouseX = _f.mouseX;
        var margin = __assign(__assign({}, LineChart.MARGIN), marginOriginal);
        var svgClasses = cx(className, '&');
        var innerWidth = width - margin.left - margin.right;
        var innerHeight = height - margin.top - margin.bottom;
        /**
         * x axis
         */
        var xScale = d3Scale
            .scaleTime()
            .domain([xAxisMin, xAxisMax])
            .range([0, innerWidth]);
        var xFinalFormatter = xAxisFormatter
            ? xAxisFormatter
            : xScale.tickFormat();
        var allYFields = lodash_1.default.compact(yAxisFields.concat(y2AxisFields));
        // This is used to map x mouse values back to data points.
        var xPointMap = lodash_1.default.reduce(data, function (acc, d) {
            // `floor` to avoid rounding errors, it doesn't need to be super precise
            // since we're dealing with pixels
            var point = Math.floor(xScale(d[xAxisField]));
            lodash_1.default.each(allYFields, function (field) {
                lodash_1.default.set(acc, "".concat(point, ".y.").concat(field), d[field]);
                lodash_1.default.set(acc, "".concat(point, ".x"), d[xAxisField]);
            });
            return acc;
        }, {});
        var xPoints = lodash_1.default.map(lodash_1.default.keys(xPointMap), lodash_1.default.toNumber);
        /**
         * y axis
         */
        var yScale = d3Scale
            .scaleLinear()
            .domain([yAxisMin, yAxisMax])
            .range([innerHeight, 0]);
        var yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();
        var yFinalFormatter = yAxisTooltipDataFormatter
            ? yAxisTooltipDataFormatter
            : yAxisFinalFormatter;
        var yAxisHasLinesFinal = !(yAxisIsStacked && !yAxisHasPoints);
        var yAxisHasPointsFinal = yAxisHasPoints || yAxisIsStacked;
        /**
         * y2 axis
         */
        var y2Axis = {};
        var y2AxisLegend = null;
        var y2AxisToolTip = null;
        if (y2AxisFields) {
            var y2Scale = d3Scale
                .scaleLinear()
                .domain([y2AxisMin, y2AxisMax])
                .range([innerHeight, 0]);
            var y2AxisFinalFormatter = y2AxisFormatter
                ? y2AxisFormatter
                : y2Scale
                    ? y2Scale.tickFormat()
                    : lodash_1.default.identity;
            var y2FinalFormatter_1 = y2AxisTooltipDataFormatter
                ? y2AxisTooltipDataFormatter
                : y2AxisFinalFormatter;
            var y2AxisHasPointsFinal_1 = y2AxisHasPoints || y2AxisIsStacked;
            var y2AxisHasLinesFinal_1 = !(y2AxisIsStacked && !y2AxisHasPoints);
            y2Axis = this.renderY2Axis(xScale, y2Scale, y2AxisFinalFormatter, margin);
            y2AxisLegend = lodash_1.default.map(y2AxisFields, function (field, index) { return (react_1.default.createElement(Legend_1.default.Item, { key: index, hasPoint: y2AxisHasPointsFinal_1, hasLine: y2AxisHasLinesFinal_1, color: lodash_1.default.get(colorMap, field, palette[y2AxisColorOffset + index + (yAxisFields.length % palette.length)]), pointKind: y2AxisHasPoints ? y2AxisColorOffset + index + yAxisFields.length : 1 }, lodash_1.default.get(legend, field, field))); });
            y2AxisToolTip = lodash_1.default.map(y2AxisFields, function (field, index) {
                return !lodash_1.default.isNil(lodash_1.default.get(xPointMap, mouseX + '.y.' + field)) ? (react_1.default.createElement(Legend_1.default.Item, { key: index, hasPoint: y2AxisHasPointsFinal_1, hasLine: y2AxisHasLinesFinal_1, color: lodash_1.default.get(colorMap, field, palette[y2AxisColorOffset +
                        index +
                        (yAxisFields.length % palette.length)]), pointKind: y2AxisHasPoints
                        ? y2AxisColorOffset + index + yAxisFields.length
                        : 1 }, yAxisTooltipFormatter(lodash_1.default.get(legend, field, field), y2FinalFormatter_1(lodash_1.default.get(xPointMap, mouseX + '.y.' + field)), lodash_1.default.get(xPointMap, mouseX + '.y.' + field)))) : null;
            });
        }
        if (lodash_1.default.isEmpty(data) || width < 1 || height < 1 || isLoading) {
            var emptyStateWrapper = (0, component_types_1.getFirst)(this.props, LineChart.EmptyStateWrapper) || react_1.default.createElement(LineChart.EmptyStateWrapper, { Title: 'You have no data.' });
            var emptyStateWrapperProps = lodash_1.default.get(emptyStateWrapper, 'props', {});
            var emptyStateWrapperChildren = lodash_1.default.get(emptyStateWrapperProps, 'children', []);
            return (react_1.default.createElement(EmptyStateWrapper_1.default, __assign({}, emptyStateWrapperProps, { isEmpty: lodash_1.default.isEmpty(data), isLoading: isLoading }),
                emptyStateWrapperChildren,
                react_1.default.createElement("svg", __assign({}, (0, lodash_1.omit)(passThroughs, nonPassThroughs), { className: svgClasses, width: width, height: height }),
                    react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                        react_1.default.createElement(Axis_1.default, { orient: 'left', scale: yScale, tickFormat: yAxisFormatter })),
                    react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(innerHeight + margin.top, ")") },
                        react_1.default.createElement(Axis_1.default, { orient: 'bottom', scale: xScale, tickFormat: xFinalFormatter })))));
        }
        return (react_1.default.createElement("svg", __assign({}, (0, lodash_1.omit)(passThroughs, nonPassThroughs), { className: svgClasses, width: width, height: height }),
            react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") }, hasToolTips && isHovering && !lodash_1.default.isNil(mouseX) ? (react_1.default.createElement(ToolTip_1.ToolTipDumb, { isLight: true, isExpanded: true, flyOutMaxWidth: 'none', alignment: mouseX < innerWidth * 0.15
                    ? 'start'
                    : mouseX > innerWidth * 0.85
                        ? 'end'
                        : 'center' },
                react_1.default.createElement(ToolTip_1.ToolTipDumb.Target, { elementType: 'g' },
                    react_1.default.createElement("path", { className: cx('&-tooltip-line'), d: "M".concat(mouseX, ",0 L").concat(mouseX, ",").concat(innerHeight) })),
                react_1.default.createElement(ToolTip_1.ToolTipDumb.Title, null, xAxisTooltipFormatter(lodash_1.default.get(xPointMap, "".concat(mouseX, ".x")))),
                react_1.default.createElement(ToolTip_1.ToolTipDumb.Body, null,
                    react_1.default.createElement(Legend_1.default, { hasBorders: false, isReversed: yAxisIsStacked },
                        lodash_1.default.map(yAxisFields, function (field, index) {
                            return !lodash_1.default.isNil(lodash_1.default.get(xPointMap, mouseX + '.y.' + field)) ? (react_1.default.createElement(Legend_1.default.Item, { key: index, hasPoint: yAxisHasPointsFinal, hasLine: yAxisHasLinesFinal, color: lodash_1.default.get(colorMap, field, palette[(index + yAxisColorOffset) % palette.length]), pointKind: yAxisHasPoints ? index + yAxisColorOffset : 1 }, yAxisTooltipFormatter(lodash_1.default.get(legend, field, field), yFinalFormatter(lodash_1.default.get(xPointMap, mouseX + '.y.' + field)), lodash_1.default.get(xPointMap, mouseX + '.y.' + field)))) : null;
                        }),
                        y2AxisToolTip)))) : null),
            react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(innerHeight + margin.top, ")") },
                react_1.default.createElement(Axis_1.default, { orient: 'bottom', scale: xScale, outerTickSize: 0, tickFormat: xFinalFormatter, tickCount: xAxisTickCount, ticks: xAxisTicks, textOrientation: xAxisTextOrientation }),
                hasLegend ? (react_1.default.createElement(ContextMenu_1.default, { direction: 'down', alignment: 'center', directonOffset: (margin.bottom / 2 + Legend_1.default.HEIGHT / 2) *
                        -1 /* should center the legend in the bottom margin */ },
                    react_1.default.createElement(ContextMenu_1.default.Target, { elementType: 'g' },
                        react_1.default.createElement("rect", { className: cx('&-invisible'), width: innerWidth, height: margin.bottom })),
                    react_1.default.createElement(ContextMenu_1.default.FlyOut, { className: cx('&-legend-container') },
                        react_1.default.createElement(Legend_1.default, { orient: 'horizontal' },
                            lodash_1.default.map(yAxisFields, function (field, index) { return (react_1.default.createElement(Legend_1.default.Item, { key: index, hasPoint: yAxisHasPointsFinal, hasLine: yAxisHasLinesFinal, color: lodash_1.default.get(colorMap, field, palette[index + (yAxisColorOffset % palette.length)]), pointKind: yAxisHasPoints ? index + yAxisColorOffset : 1 }, lodash_1.default.get(legend, field, field))); }),
                            y2AxisLegend)))) : null),
            xAxisTitle ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top + innerHeight, ")") },
                react_1.default.createElement(AxisLabel_1.default, { orient: 'bottom', width: innerWidth, height: margin.bottom, label: xAxisTitle, color: lodash_1.default.isString(xAxisTitleColor)
                        ? xAxisTitleColor
                        : palette[xAxisTitleColor % palette.length] }))) : null,
            react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                react_1.default.createElement(Axis_1.default, { orient: 'left', scale: yScale, tickFormat: yAxisFinalFormatter, tickCount: yAxisTickCount, textOrientation: yAxisTextOrientation })),
            yAxisTitle ? (react_1.default.createElement("g", { transform: "translate(0, ".concat(margin.top, ")") },
                react_1.default.createElement(AxisLabel_1.default, { orient: 'left', width: margin.left, height: innerHeight, label: yAxisTitle, color: lodash_1.default.isString(yAxisTitleColor)
                        ? yAxisTitleColor
                        : palette[yAxisTitleColor % palette.length] }))) : null,
            lodash_1.default.get(y2Axis, 'axis', null),
            lodash_1.default.get(y2Axis, 'title', null),
            react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                react_1.default.createElement(Lines_1.default, { xScale: xScale, yScale: yScale, xField: xAxisField, yFields: yAxisFields, yStackedMax: yAxisMax, data: data || {}, isStacked: yAxisIsStacked, colorMap: colorMap, palette: palette, colorOffset: yAxisColorOffset })),
            yAxisHasPoints ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                react_1.default.createElement(Points_1.default, { xScale: xScale, yScale: yScale, xField: xAxisField, yFields: yAxisFields, yStackedMax: yAxisMax, data: data, isStacked: yAxisIsStacked, colorMap: colorMap, palette: palette, colorOffset: yAxisColorOffset }))) : null,
            lodash_1.default.get(y2Axis, 'lines', null),
            lodash_1.default.get(y2Axis, 'points', null),
            hasToolTips ? (react_1.default.createElement("g", { transform: "translate(".concat(margin.left, ", ").concat(margin.top, ")") },
                react_1.default.createElement("rect", { className: cx('&-invisible'), width: innerWidth, height: innerHeight, onMouseMove: function (event) {
                        _this.handleToolTipHoverZone(event, xPoints);
                    }, onMouseOut: function () {
                        _this.setState({ isHovering: false });
                    } }))) : null));
    };
    LineChart.displayName = 'LineChart';
    LineChart.peek = {
        description: "The `LineChart` presents data over time. Currently only dates are supported on the x axis and numeric values on the y. If you need discrete values on the x axis, consider using the `BarChart` instead.",
        categories: ['visualizations', 'charts'],
        madeFrom: ['ContextMenu', 'ToolTip'],
    };
    LineChart.MARGIN = {
        top: 10,
        right: 80,
        bottom: 65,
        left: 80,
    };
    LineChart.propTypes = {
        /**
            Appended to the component-specific class names set on the root element.
        */
        className: string,
        /**
            Height of the chart.
        */
        height: number,
        /**
            Width of the chart.
        */
        width: number,
        /**
            An object defining the margins of the chart. These margins will contain
            the axis and labels.
        */
        margin: shape({
            top: number,
            right: number,
            bottom: number,
            left: number,
        }),
        /**
            Data for the chart. E.g.
    
                [
                    { x: new Date('2015-01-01') , y: 1 } ,
                    { x: new Date('2015-01-02') , y: 2 } ,
                    { x: new Date('2015-01-03') , y: 3 } ,
                    { x: new Date('2015-01-04') , y: 2 } ,
                    { x: new Date('2015-01-05') , y: 5 } ,
                ]
        */
        data: arrayOf(object),
        /**
            An object with human readable names for fields that will be used for
            legends and tooltips. E.g:
    
                {
                    x: 'Date',
                    y: 'Impressions',
                }
        */
        legend: object,
        /**
            Controls the visibility of the \`LoadingMessage\`.
        */
        isLoading: bool,
        /**
            Show tool tips on hover.
        */
        hasToolTips: bool,
        /**
            Show a legend at the bottom of the chart.
        */
        hasLegend: bool,
        /**
            Takes one of the palettes exported from \`lucid.chartConstants\`.
            Available palettes:
    
            - \`PALETTE_7\` (default)
            - \`PALETTE_30\`
            - \`PALETTE_MONOCHROME_0_5\`
            - \`PALETTE_MONOCHROME_1_5\`
            - \`PALETTE_MONOCHROME_2_5\`
            - \`PALETTE_MONOCHROME_3_5\`
            - \`PALETTE_MONOCHROME_4_5\`
            - \`PALETTE_MONOCHROME_5_5\`
            - \`PALETTE_MONOCHROME_6_5\`
        */
        palette: arrayOf(string),
        /**
            You can pass in an object if you want to map fields to
            \`lucid.chartConstants\` or custom colors:
    
                {
                    'imps': COLOR_0,
                    'rev': COLOR_3,
                    'clicks': '#abc123',
                }
        */
        colorMap: object,
        /**
            The field we should look up your x data by. The data must be valid
            javascript dates.
        */
        xAxisField: string,
        /**
            The minimum date the x axis should display. Typically this will be the
            smallest items from your dataset.
        */
        xAxisMin: instanceOf(Date),
        /**
            The maximum date the x axis should display. This should almost always be
            the largest date from your dataset.
        */
        xAxisMax: instanceOf(Date),
        /**
            An optional function used to format your x axis data. If you don't
            provide anything, we use the default D3 date variable formatter.
        */
        xAxisFormatter: func,
        /**
            An optional function used to format your x axis dates in the tooltips.
        */
        xAxisTooltipFormatter: func,
        /**
            There are some cases where you need to only show a "sampling" of ticks on
            the x axis. This number will control that.
        */
        xAxisTickCount: number,
        /**
            In some cases xAxisTickCount is not enough and you want to specify
            exactly where the tick marks should appear on the x axis. This prop takes
            an array of dates (currently only dates are supported for the x axis).
            This prop will override the \`xAxisTickCount\` prop.
        */
        xAxisTicks: arrayOf(instanceOf(Date)),
        /**
            Set a title for the x axis.
        */
        xAxisTitle: string,
        /**
            Set a color for the x axis title. Use the color constants exported off
            \`lucid.chartConstants\`. E.g.:
    
            - \`COLOR_0\`
            - \`COLOR_GOOD\`
            - \`'#123abc'\` // custom color hex
    
            \`number\` is supported only for backwards compatability.
        */
        xAxisTitleColor: oneOfType([number, string]),
        /**
            Determines the orientation of the tick text. This may override what the orient prop
            tries to determine.
        */
        xAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),
        /**
            An array of your y axis fields. Typically this will just be a single item
            unless you need to display multiple lines. The order of the array
            determines the series order in the chart.
        */
        yAxisFields: arrayOf(string),
        /**
            The minimum number the y axis should display. Typically this should be
            \`0\`.
        */
        yAxisMin: number,
        /**
            The maximum number the y axis should display. This should almost always
            be the largest number from your dataset.
        */
        yAxisMax: number,
        /**
            An optional function used to format your y axis data. If you don't
            provide anything, we use the default D3 formatter.
        */
        yAxisFormatter: func,
        /**
            Stack the y axis data. This is only useful if you have multiple
            \`yAxisFields\`. Stacking will cause the chart to be aggregated by sum.
        */
        yAxisIsStacked: bool,
        /**
            Display points along with the y axis lines.
        */
        yAxisHasPoints: bool,
        /**
            There are some cases where you need to only show a "sampling" of ticks on
            the y axis. This number will control that.
        */
        yAxisTickCount: number,
        /**
            Set a title for the y axis.
        */
        yAxisTitle: string,
        /**
            Set a color for the y axis title. Use the color constants exported off
            \`lucid.chartConstants\`. E.g.:
    
            - \`COLOR_0\`
            - \`COLOR_GOOD\`
            - \`'#123abc'\` // custom color hex
    
            \`number\` is supported only for backwards compatability.
        */
        yAxisTitleColor: oneOfType([number, string]),
        /**
            An optional function used to format your y axis titles and data in the
            tooltips. The first value is the name of your y field, the second value
            is your post-formatted y value, and the third value is your non-formatted
            y-value.  Signature: \`(yField, yValueFormatted, yValue) => {}\`
        */
        yAxisTooltipFormatter: func,
        /**
            An optional function used to format data in the tooltips.
        */
        yAxisTooltipDataFormatter: func,
        /**
            Set the starting index where colors start rotating for points and lines
            along the y axis.
        */
        yAxisColorOffset: number,
        /**
            An array of your y2 axis fields. Typically this will just be a single
            item unless you need to display multiple lines. The order of the array
            determines the series order in the chart.
        */
        y2AxisFields: arrayOf(string),
        /**
            The minimum number the y2 axis should display. Typically this should be
            \`0\`.
        */
        y2AxisMin: number,
        /**
            The maximum number the y2 axis should display. This should almost always
            be the largest number from your dataset.
        */
        y2AxisMax: number,
        /**
            An optional function used to format your y2 axis data. If you don't
            provide anything, we use the default D3 formatter.
        */
        y2AxisFormatter: func,
        /**
            An optional function used to format data in the tooltips.
        */
        y2AxisTooltipDataFormatter: func,
        /**
            Stack the y2 axis data. This is only useful if you have multiple
            \`y2AxisFields\`. Stacking will cause the chart to be aggregated by sum.
        */
        y2AxisIsStacked: bool,
        /**
            Display points along with the y2 axis lines.
        */
        y2AxisHasPoints: bool,
        /**
            There are some cases where you need to only show a "sampling" of ticks on
            the y2 axis. This number will control that.
        */
        y2AxisTickCount: number,
        /**
            Set a title for the y2 axis.
        */
        y2AxisTitle: string,
        /**
            Set a color for the y2 axis title. Use the color constants exported off
            \`lucid.chartConstants\`. E.g.:
    
            - \`COLOR_0\`
            - \`COLOR_GOOD\`
            - \`'#123abc'\` // custom color hex
    
            \`number\` is supported only for backwards compatability.
        */
        y2AxisTitleColor: oneOfType([number, string]),
        /**
            Set the starting index where colors start rotating for points and lines
            along the y2 axis.
        */
        y2AxisColorOffset: number,
        /**
            Determines the orientation of the tick text. This may override what the orient prop
            tries to determine.
        */
        yAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),
    };
    LineChart.defaultProps = {
        height: 400,
        width: 1000,
        margin: {
            top: 10,
            right: 80,
            bottom: 65,
            left: 80,
        },
        hasToolTips: true,
        hasLegend: false,
        palette: chartConstants.PALETTE_7,
        xAxisField: 'x',
        xAxisFormatter: chart_helpers_1.formatDate,
        // E.g. "Mon 06/06/2016 15:46:19"
        xAxisTooltipFormatter: d3TimeFormat.timeFormat('%a %x %X'),
        xAxisTickCount: null,
        xAxisTicks: undefined,
        xAxisTitle: null,
        xAxisTitleColor: '#000',
        xAxisTextOrientation: 'horizontal',
        yAxisFields: ['y'],
        yAxisMin: 0,
        yAxisIsStacked: false,
        yAxisHasPoints: true,
        yAxisTickCount: null,
        yAxisTitle: null,
        yAxisTitleColor: '#000',
        yAxisTooltipFormatter: function (yField, yValueFormatted) {
            return "".concat(yField, ": ").concat(yValueFormatted);
        },
        yAxisColorOffset: 0,
        y2AxisFields: [],
        y2AxisMin: 0,
        y2AxisIsStacked: false,
        y2AxisHasPoints: true,
        y2AxisTickCount: null,
        y2AxisTitle: null,
        y2AxisTitleColor: '#000',
        y2AxisColorOffset: 1,
        yAxisTextOrientation: 'horizontal',
    };
    LineChart.EmptyStateWrapper = EmptyStateWrapper_1.default;
    return LineChart;
}(react_1.default.Component));
exports.default = LineChart;
//# sourceMappingURL=LineChart.js.map