"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerticalListMenuDumb = void 0;
var lodash_1 = __importStar(require("lodash"));
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var style_helpers_1 = require("../../util/style-helpers");
var component_types_1 = require("../../util/component-types");
var state_management_1 = require("../../util/state-management");
var reducers = __importStar(require("./VerticalListMenu.reducers"));
var ChevronIcon_1 = __importDefault(require("../Icon/ChevronIcon/ChevronIcon"));
var Collapsible_1 = __importDefault(require("../Collapsible/Collapsible"));
var cx = style_helpers_1.lucidClassNames.bind('&-VerticalListMenu');
var func = prop_types_1.default.func, arrayOf = prop_types_1.default.arrayOf, bool = prop_types_1.default.bool, string = prop_types_1.default.string, number = prop_types_1.default.number, node = prop_types_1.default.node, object = prop_types_1.default.object, shape = prop_types_1.default.shape;
var Item = function (_props) { return null; };
Item.peek = {
    description: "\n\t\tA child item that can contain content or another VerticalListMenu.\n\t",
};
Item.displayName = 'VerticalListMenu.Item';
Item.propTypes = {
    /**
                    Show or hide the expand button. Should be \`true\` if you want to
                    nest menus.
                */
    hasExpander: bool,
    /**
                Determines the visibility of nested menus.
            */
    isExpanded: bool,
    /**
                If \`true\` then a small bar on the left side of the item will be
                shown indicating this item is selected.
            */
    isSelected: bool,
    /**
                Determines the visibility of the small bar on the left when the user
                hovers over the item. This should indicate to the user that an item
                is clickable.
            */
    isActionable: bool,
    /**
                Called when the user clicks the main body of the item.  Signature:
                \`(index, { event, props}) => {}\`
            */
    onSelect: func,
    /**
                Called when the user clicks the expand button.  Signature:
                \`(index, { event, props}) => {}\`
            */
    onToggle: func,
    /**
                Props that are passed through to the underlying Collapsible component
                if the item has children.
            */
    Collapsible: shape(Collapsible_1.default.propTypes),
};
var defaultProps = {
    onSelect: lodash_1.default.noop,
    onToggle: lodash_1.default.noop,
    expandedIndices: [],
    selectedIndices: [],
};
var VerticalListMenu = /** @class */ (function (_super) {
    __extends(VerticalListMenu, _super);
    function VerticalListMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleToggle = function (index, itemChildProp, event) {
            var onToggle = itemChildProp.onToggle;
            // Prevent the user from also selecting the current item.
            event.stopPropagation();
            _this.props.onToggle(index, { event: event, props: itemChildProp });
            if (onToggle) {
                onToggle(index, { event: event, props: itemChildProp });
            }
        };
        _this.handleClickItem = function (index, itemChildProp, event) {
            var onSelect = itemChildProp.onSelect;
            _this.props.onSelect(index, { event: event, props: itemChildProp });
            if (onSelect) {
                onSelect(index, { event: event, props: itemChildProp });
            }
        };
        return _this;
    }
    VerticalListMenu.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, className = _a.className, style = _a.style, selectedIndices = _a.selectedIndices, expandedIndices = _a.expandedIndices, passThroughs = __rest(_a, ["children", "className", "style", "selectedIndices", "expandedIndices"]);
        var itemChildProps = lodash_1.default.map((0, component_types_1.findTypes)(this.props, VerticalListMenu.Item), 'props');
        return (react_1.default.createElement("ul", __assign({}, (0, lodash_1.omit)(passThroughs, [
            'children',
            'className',
            'style',
            'selectedIndices',
            'expandedIndices',
            'onSelect',
            'onToggle',
            'initialState',
            'callbackId',
        ]), { className: cx('&', className), style: style }),
            lodash_1.default.map(itemChildProps, function (itemChildProp, index) {
                var _a = itemChildProp.hasExpander, hasExpander = _a === void 0 ? false : _a, _b = itemChildProp.isActionable, isActionable = _b === void 0 ? true : _b, _c = itemChildProp.Collapsible, collapsibleProps = _c === void 0 ? Collapsible_1.default.defaultProps : _c;
                var itemChildrenAsArray = react_1.default.Children.toArray(itemChildProp.children);
                // Was not able to get `child.Type` to work correctly, I suspect this
                // is due to the way we wrap components with createLucidComponentDefinition
                var listChildren = lodash_1.default.filter(itemChildrenAsArray, function (child) {
                    return lodash_1.default.get(child, 'type.displayName', '') === 'VerticalListMenu';
                });
                var otherChildren = lodash_1.default.filter(itemChildrenAsArray, function (child) {
                    return lodash_1.default.get(child, 'type.displayName', '') !== 'VerticalListMenu';
                });
                // If the prop is found on the child, it should override what was
                // passed in at the top level for selectedIndices and expandedIndices
                var actualIsExpanded = lodash_1.default.has(itemChildProp, 'isExpanded')
                    ? lodash_1.default.get(itemChildProp, 'isExpanded', true)
                    : lodash_1.default.includes(expandedIndices, index);
                var actualIsSelected = lodash_1.default.has(itemChildProp, 'isSelected')
                    ? lodash_1.default.get(itemChildProp, 'isSelected', false)
                    : lodash_1.default.includes(selectedIndices, index);
                return (react_1.default.createElement("li", __assign({ key: index }, itemChildProp.passThroughs, { className: cx('&-Item', itemChildProp.className) }),
                    react_1.default.createElement("div", { className: cx('&-Item-content', {
                            '&-Item-content-is-selected': actualIsSelected,
                            '&-Item-content-is-not-selected': !actualIsSelected,
                            '&-Item-content-is-expanded': actualIsExpanded,
                            '&-Item-content-is-actionable': isActionable,
                        }), onClick: lodash_1.default.partial(_this.handleClickItem, index, itemChildProp) },
                        react_1.default.createElement("div", { className: cx('&-Item-content-body') },
                            react_1.default.createElement("div", { className: cx('&-Item-content-text') }, otherChildren),
                            hasExpander ? (react_1.default.createElement("div", { className: cx('&-Item-expander'), onClick: lodash_1.default.partial(_this.handleToggle, index, itemChildProp) },
                                react_1.default.createElement(ChevronIcon_1.default, { size: 12, direction: actualIsExpanded ? 'up' : 'down' }))) : null)),
                    !lodash_1.default.isEmpty(listChildren) ? (react_1.default.createElement(Collapsible_1.default, __assign({}, collapsibleProps, { className: cx('&-Item-nested-list'), isExpanded: actualIsExpanded }), listChildren)) : null));
            }),
            children));
    };
    VerticalListMenu.displayName = 'VerticalListMenu';
    VerticalListMenu.Item = Item;
    VerticalListMenu.peek = {
        description: "Used primarily for navigation lists. It supports nesting `VerticalListMenu`s below `VerticalListMenu.Item`s and animating expanding of those sub lists.  The default reducer behavior is for only one `VerticalListMenu.Item` to be selected at any given time; that default is easily overridden by handling `onSelect` yourself.",
        categories: ['navigation'],
        madeFrom: ['ChevronIcon'],
    };
    VerticalListMenu.reducers = reducers;
    // TODO: remove this once we move to only buildModernHybridComponent
    VerticalListMenu.definition = {
        statics: {
            Item: Item,
            reducers: reducers,
            peek: {
                description: "Used primarily for navigation lists. It supports nesting `VerticalListMenu`s below `VerticalListMenu.Item`s and animating expanding of those sub lists.  The default reducer behavior is for only one `VerticalListMenu.Item` to be selected at any given time; that is easily overridden by handling `onSelect` yourself.",
                categories: ['navigation'],
                madeFrom: ['ChevronIcon'],
            },
        },
    };
    VerticalListMenu.propTypes = {
        /**
            Regular \`children\` aren't really used in this component, but if you do
            add them they will be placed at the end of the component. You should be
            using \`VerticalListMenu.Item\`s instead of regular children.
        */
        children: node,
        /**
            Appended to the component-specific class names set on the root element.
        */
        className: string,
        /**
            Passed through to the root element.
        */
        style: object,
        /**
            Indicates which of the \`VerticalListMenu.Item\` children are currently
            selected. You can also put the \`isSelected\` prop directly on the
            \`VerticalListMenu.Item\`s if you wish.
        */
        selectedIndices: arrayOf(number),
        /**
            Indicates which of the \`VerticalListMenu.Item\` children are currently
            expanded. You can also put the \`isExpanded\` prop directly on the
            \`VerticalListMenu.Item\`s if you wish.
        */
        expandedIndices: arrayOf(number),
        /**
            Callback fired when the user selects a \`VerticalListMenu.Item\`.
            Signature: \`(index, { event, props }) => {}\`
        */
        onSelect: func,
        /**
            Callback fired when the user expands or collapses an expandable
            \`VerticalListMenu.Item\`.  Signature:
            \`(index, { event, props }) => {}\`
        */
        onToggle: func,
    };
    VerticalListMenu.defaultProps = defaultProps;
    return VerticalListMenu;
}(react_1.default.Component));
exports.VerticalListMenuDumb = VerticalListMenu;
exports.default = (0, state_management_1.buildModernHybridComponent)(VerticalListMenu, { reducers: reducers });
//# sourceMappingURL=VerticalListMenu.js.map