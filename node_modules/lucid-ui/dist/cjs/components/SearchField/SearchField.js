"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchFieldDumb = void 0;
/* eslint-disable react/prop-types */
var lodash_1 = __importDefault(require("lodash"));
var react_1 = __importStar(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var style_helpers_1 = require("../../util/style-helpers");
var component_types_1 = require("../../util/component-types");
var state_management_1 = require("../../util/state-management");
var TextField_1 = __importDefault(require("../TextField/TextField"));
var SearchIcon_1 = __importDefault(require("../Icon/SearchIcon/SearchIcon"));
var SearchField_reducers_1 = __importDefault(require("./SearchField.reducers"));
var cx = style_helpers_1.lucidClassNames.bind('&-SearchField');
var bool = prop_types_1.default.bool, func = prop_types_1.default.func, node = prop_types_1.default.node, number = prop_types_1.default.number, oneOfType = prop_types_1.default.oneOfType, string = prop_types_1.default.string;
var SearchFieldIcon = function (_props) { return null; };
SearchFieldIcon.peek = {
    description: "Icon this is displayed on the right side of the SearchField. Any of the lucid `*Icon` components should work.",
};
SearchFieldIcon.displayName = 'SearchField.Icon';
SearchFieldIcon.propName = 'Icon';
var SearchFieldTextField = function (_props) { return null; };
SearchFieldTextField.peek = {
    description: "Icon this is displayed on the right side of the SearchField. Any of the lucid `*Icon` components should work.",
};
SearchFieldTextField.displayName = 'SearchField.TextField';
SearchFieldTextField.propName = 'TextField';
/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */
var nonPassThroughs = [
    'onChange',
    'onChangeDebounced',
    'debounceLevel',
    'onSubmit',
    'value',
    'isValid',
    'isDisabled',
    'placeholder',
    'className',
    'Icon',
    'TextField',
    'initialState',
    'callbackId',
];
var SearchField = /** @class */ (function (_super) {
    __extends(SearchField, _super);
    function SearchField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.textFieldElement = react_1.default.createRef();
        _this.focus = function (options) {
            _this.textFieldElement.current &&
                _this.textFieldElement.current.focus(options);
        };
        return _this;
    }
    SearchField.prototype.render = function () {
        var _a = this, props = _a.props, _b = _a.props, className = _b.className, isDisabled = _b.isDisabled, isValid = _b.isValid, onChange = _b.onChange, onChangeDebounced = _b.onChangeDebounced, debounceLevel = _b.debounceLevel, onSubmit = _b.onSubmit, placeholder = _b.placeholder, value = _b.value, autoComplete = _b.autoComplete, passThroughs = __rest(_b, ["className", "isDisabled", "isValid", "onChange", "onChangeDebounced", "debounceLevel", "onSubmit", "placeholder", "value", "autoComplete"]);
        var Icon = SearchField.Icon;
        var textFieldProps = lodash_1.default.get((0, component_types_1.getFirst)(props, SearchField.TextField), 'props') || {
            isDisabled: isDisabled,
            onChange: onChange,
            onChangeDebounced: onChangeDebounced,
            debounceLevel: debounceLevel,
            onSubmit: onSubmit,
            placeholder: placeholder,
            isMultiLine: false,
            value: value,
            autoComplete: autoComplete,
        };
        var textFieldElement = (react_1.default.createElement(TextField_1.default, __assign({ ref: this.textFieldElement }, textFieldProps)));
        var isIconActive = lodash_1.default.isUndefined(isValid)
            ? !lodash_1.default.isEmpty(lodash_1.default.get(textFieldElement, 'props.value'))
            : isValid;
        var defaultIcon = (react_1.default.createElement(SearchIcon_1.default, { size: 12, className: cx('&-Icon', { '&-Icon-active': isIconActive }) }));
        var iconElement = (0, component_types_1.getFirst)(props, Icon);
        var iconChildren = lodash_1.default.get(iconElement, 'props.children');
        var icon = iconChildren
            ? (0, react_1.createElement)(iconChildren.type, __assign(__assign({}, iconChildren.props), { className: cx('&-Icon', { '&-Icon-active': isIconActive }, iconChildren.props.className) }))
            : defaultIcon;
        return (react_1.default.createElement("div", __assign({}, lodash_1.default.omit(passThroughs, nonPassThroughs), { className: cx('&', className) }),
            textFieldElement,
            react_1.default.createElement("div", { className: cx('&-Icon-container', {
                    '&-Icon-is-disabled': isDisabled,
                }) }, icon)));
    };
    SearchField.displayName = 'SearchField';
    SearchField.TextField = SearchFieldTextField;
    SearchField.Icon = SearchFieldIcon;
    SearchField.peek = {
        description: "A wrapper around `TextField` that styles it for a search use-case. The icon and TextField are customizable through child components.",
        categories: ['controls', 'text'],
        madeFrom: ['TextField', 'SearchIcon'],
    };
    SearchField.reducers = SearchField_reducers_1.default;
    SearchField.propTypes = {
        /**
            Fires an event every time the user types text into the TextField.
            Signature: \`(value, { event, props }) => {}\`
        */
        onChange: func,
        /**
            Fires an event, debounced by \`debounceLevel\`, when the user types text
            into the TextField.  Signature: \`(value, { event, props }) => {}\`
        */
        onChangeDebounced: func,
        /**
            Number of milliseconds to debounce the \`onChangeDebounced\` callback.
            Only useful if you provide an \`onChangeDebounced\` handler.
        */
        debounceLevel: number,
        /**
            Fires an event when the user hits "enter" from the SearchField.
            Signature: \`(value, { event, props }) => {}\`
        */
        onSubmit: func,
        /**
            Set the value of the input.
        */
        value: oneOfType([number, string]),
        /**
            Controls the highlighting of the search icon. Should be passed \`true\`
            when the search text is valid, e.g. contains enough characters to perform
            a search.
        */
        isValid: bool,
        /**
            Disables the SearchField by greying it out.
        */
        isDisabled: bool,
        /**
            placeholder value
        */
        placeholder: string,
        /**
            Appended to the component-specific class names set on the root element.
        */
        className: string,
        Icon: node /**
            Icon this is displayed on the right side of the SearchField. Any of the
            lucid \`*Icon\` components should work.
        */,
        /**
            The TextField that Searchfield is composed of.
        */
        TextField: node,
    };
    SearchField.defaultProps = {
        isDisabled: false,
        onChange: lodash_1.default.noop,
        onChangeDebounced: lodash_1.default.noop,
        debounceLevel: 500,
        onSubmit: lodash_1.default.noop,
        value: '',
    };
    return SearchField;
}(react_1.default.Component));
exports.SearchFieldDumb = SearchField;
exports.default = (0, state_management_1.buildModernHybridComponent)(SearchField, { reducers: SearchField_reducers_1.default });
//# sourceMappingURL=SearchField.js.map