"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Points = void 0;
var lodash_1 = __importStar(require("lodash"));
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var d3Shape = __importStar(require("d3-shape"));
var style_helpers_1 = require("../../util/style-helpers");
var chart_helpers_1 = require("../../util/chart-helpers");
var chartConstants = __importStar(require("../../constants/charts"));
var Point_1 = __importDefault(require("../Point/Point"));
var cx = style_helpers_1.lucidClassNames.bind('&-Points');
var arrayOf = prop_types_1.default.arrayOf, func = prop_types_1.default.func, number = prop_types_1.default.number, object = prop_types_1.default.object, bool = prop_types_1.default.bool, string = prop_types_1.default.string;
function isValidSeries(series) {
    if (lodash_1.default.isArray(series)) {
        var last = lodash_1.default.last(series);
        return lodash_1.default.isFinite(last) || lodash_1.default.isDate(last);
    }
    return lodash_1.default.isFinite(series) || lodash_1.default.isDate(series);
}
var nonPassThroughs = [
    'className',
    'palette',
    'colorMap',
    'data',
    'xScale',
    'yScale',
    'xField',
    'yFields',
    'yStackedMax',
    'colorOffset',
    'hasStroke',
    'isStacked',
    'initialState',
    'callbackId',
];
var defaultProps = {
    xField: 'x',
    yFields: ['y'],
    colorOffset: 0,
    hasStroke: true,
    isStacked: false,
    palette: chartConstants.PALETTE_7,
};
var Points = function (props) {
    var className = props.className, data = props.data, palette = props.palette, colorMap = props.colorMap, colorOffset = props.colorOffset, xField = props.xField, hasStroke = props.hasStroke, xScale = props.xScale, yFields = props.yFields, yStackedMax = props.yStackedMax, isStacked = props.isStacked, yScaleOriginal = props.yScale, passThroughs = __rest(props, ["className", "data", "palette", "colorMap", "colorOffset", "xField", "hasStroke", "xScale", "yFields", "yStackedMax", "isStacked", "yScale"]);
    // Copy the original so we can mutate it
    var yScale = yScaleOriginal.copy();
    // If we are stacked, we need to calculate a new domain based on the sum of
    // the various series' y data. One row per series.
    var transformedData = isStacked
        ? d3Shape.stack().keys(yFields)(data)
        : (0, chart_helpers_1.groupByFields)(data, yFields);
    // If we are stacked, we need to calculate a new domain based on the sum of
    // the various group's y data
    if (isStacked) {
        yScale.domain([
            yScale.domain()[0],
            yStackedMax || lodash_1.default.max(lodash_1.default.flatten(lodash_1.default.last(transformedData))),
        ]);
    }
    return (react_1.default.createElement("g", __assign({}, (0, lodash_1.omit)(passThroughs, nonPassThroughs), { className: cx(className, '&') }), lodash_1.default.map(transformedData, function (d, dIndex) {
        return lodash_1.default.map(d, function (series, seriesIndex) {
            if (isValidSeries(series)) {
                return (react_1.default.createElement(Point_1.default, { key: "".concat(seriesIndex).concat(dIndex), 
                    /* Since data contains x and y values, data values may not have a uniform type that always matches
                                the expected input of the xScale */
                    //@ts-ignore
                    x: xScale(data[seriesIndex][xField]), y: yScale(lodash_1.default.isArray(series) ? lodash_1.default.last(series) : series), hasStroke: hasStroke, kind: dIndex + colorOffset, color: lodash_1.default.get(colorMap, yFields[dIndex], palette[(dIndex + colorOffset) % palette.length]) }));
            }
        });
    })));
};
exports.Points = Points;
exports.Points.defaultProps = defaultProps;
exports.Points.displayName = 'Points';
exports.Points.peek = {
    description: "For use within an `svg`. Put some points on that data.",
    categories: ['visualizations', 'chart primitives'],
    madeFrom: ['Point'],
};
exports.Points.propTypes = {
    /**
        Appended to the component-specific class names set on the root element.
    */
    className: string,
    /**
        Takes one of the palettes exported from \`lucid.chartConstants\`.
        Available palettes:

        - \`PALETTE_7\` (default)
        - \`PALETTE_30\`
        - \`PALETTE_MONOCHROME_0_5\`
        - \`PALETTE_MONOCHROME_1_5\`
        - \`PALETTE_MONOCHROME_2_5\`
        - \`PALETTE_MONOCHROME_3_5\`
        - \`PALETTE_MONOCHROME_4_5\`
        - \`PALETTE_MONOCHROME_5_5\`
        - \`PALETTE_MONOCHROME_6_5\`
    */
    palette: arrayOf(string),
    /**
        You can pass in an object if you want to map fields to
        \`lucid.chartConstants\` or custom colors:

        {
            'imps': COLOR_0,
            'rev': COLOR_3,
            'clicks': '#abc123',
        }
    */
    colorMap: object,
    /**
        De-normalized data, e.g.

            [
                { x: 'one'   , y: 1 },
                { x: 'two'   , y: 2 },
                { x: 'three' , y: 2 },
                { x: 'four'  , y: 3 },
                { x: 'five'  , y: 4 },
            ]

        Or (be sure to set \`yFields\` to \`['y0', 'y1', 'y2', 'y3']\`)

            [
                { x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },
                { x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },
                { x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },
                { x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },
                { x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },
                { x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },
            ]
    */
    data: arrayOf(object).isRequired,
    /**
        The scale for the x axis. Must be a d3 scale. Lucid exposes the
        \`lucid.d3Scale\` library for use here.
    */
    xScale: func.isRequired,
    /**
        The scale for the y axis. Must be a d3 scale. Lucid exposes the
        \`lucid.d3Scale\` library for use here.
    */
    yScale: func.isRequired,
    /**
        The field we should look up your x data by.
    */
    xField: string,
    /**
        The field(s) we should look up your y data by. Each entry represents a
        series. Your actual y data should be numeric.
    */
    yFields: arrayOf(string),
    /**
        Typically this number can be derived from the yScale. However when we're
        \`isStacked\` we need to calculate a new domain for the yScale based on
        the sum of the data. If you need explicit control of the y max when
        stacking, pass it in here.
    */
    yStackedMax: number,
    /**
        Sometimes you might not want the colors to start rotating at the blue
        color, this number will be added the line index in determining which
        color the lines are.
    */
    colorOffset: number,
    /**
        Display a stroke around each of the points.
    */
    hasStroke: bool,
    /**
        This will stack the data. In order to stack the data we have to calculate
        a new domain for the y scale that is based on the \`sum\` of the data.
    */
    isStacked: bool,
};
exports.default = exports.Points;
//# sourceMappingURL=Points.js.map