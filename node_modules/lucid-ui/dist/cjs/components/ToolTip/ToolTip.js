"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolTipDumb = exports.nonPassThroughs = void 0;
var lodash_1 = __importStar(require("lodash"));
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var ContextMenu_1 = __importDefault(require("../ContextMenu/ContextMenu"));
var CloseIcon_1 = __importDefault(require("../Icon/CloseIcon/CloseIcon"));
var reducers = __importStar(require("./ToolTip.reducers"));
var style_helpers_1 = require("../../util/style-helpers");
var component_types_1 = require("../../util/component-types");
var state_management_1 = require("../../util/state-management");
var cx = style_helpers_1.lucidClassNames.bind('&-ToolTip');
var flyOutCx = cx.bind('&-FlyOut');
var bool = prop_types_1.default.bool, func = prop_types_1.default.func, node = prop_types_1.default.node, number = prop_types_1.default.number, object = prop_types_1.default.object, oneOf = prop_types_1.default.oneOf, string = prop_types_1.default.string, oneOfType = prop_types_1.default.oneOfType;
var Target = ContextMenu_1.default.Target, FlyOut = ContextMenu_1.default.FlyOut;
var ToolTipTarget = function (_props) { return null; };
ToolTipTarget.displayName = 'ToolTip.Target';
ToolTipTarget.peek = {
    description: "The hover target that will trigger the `ToolTip` to be displayed.",
};
ToolTipTarget.propName = 'Target';
var ToolTipTitle = function (_props) { return null; };
ToolTipTitle.displayName = 'ToolTip.Title';
ToolTipTitle.peek = {
    description: "A not recommended title, optionally displayed at the top of the `ToolTip`.",
};
ToolTipTitle.propName = 'Title';
var ToolTipBody = function (_props) { return null; };
ToolTipBody.displayName = 'ToolTip.Body';
ToolTipBody.peek = {
    description: "The body of the `ToolTip`.",
};
ToolTipBody.propName = 'Body';
/** TODO: Remove nonPassThroughs when the component is converted to a functional component */
exports.nonPassThroughs = [
    'children',
    'className',
    'isCloseable',
    'isLight',
    'onClose',
    'style',
    'flyOutStyle',
    'flyOutMaxWidth',
    'direction',
    'alignment',
    'isExpanded',
    'onMouseOver',
    'onMouseOut',
    'portalId',
    'Title',
    'Body',
    'Target',
    'initialState',
];
var ToolTip = /** @class */ (function (_super) {
    __extends(ToolTip, _super);
    function ToolTip(props) {
        var _this = _super.call(this, props) || this;
        _this.handleMouseOut = function (event) {
            setTimeout(function () {
                var _a = _this, props = _a.props, _b = _a.state, isMouseOverFlyout = _b.isMouseOverFlyout, isMouseOverTarget = _b.isMouseOverTarget, onMouseOut = _a.props.onMouseOut;
                if (!isMouseOverFlyout && !isMouseOverTarget) {
                    onMouseOut && onMouseOut({ props: props, event: event });
                }
            }, 100);
        };
        _this.handleMouseOverFlyout = function () {
            _this.setState({ isMouseOverFlyout: true });
        };
        _this.handleMouseOutFlyout = function (event) {
            _this.setState({ isMouseOverFlyout: false });
            _this.handleMouseOut(event);
        };
        _this.handleMouseOverTarget = function (event) {
            _this.setState({ isMouseOverTarget: true });
            _this.props.onMouseOver &&
                _this.props.onMouseOver({ props: _this.props, event: event });
        };
        _this.handleMouseOutTarget = function (event) {
            _this.setState({ isMouseOverTarget: false });
            _this.handleMouseOut(event);
        };
        _this.handleClose = function (_a) {
            var event = _a.event, props = _a.props;
            _this.props.onClose && _this.props.onClose({ event: event, props: _this.props });
        };
        _this.state = {
            isMouseOverFlyout: false,
            isMouseOverTarget: false,
            isExpanded: false,
        };
        return _this;
    }
    ToolTip.prototype.render = function () {
        var _a = this.props, className = _a.className, alignment = _a.alignment, direction = _a.direction, flyOutMaxWidth = _a.flyOutMaxWidth, flyOutStyle = _a.flyOutStyle, isCloseable = _a.isCloseable, isExpanded = _a.isExpanded, isLight = _a.isLight, portalId = _a.portalId, style = _a.style, passThroughs = __rest(_a, ["className", "alignment", "direction", "flyOutMaxWidth", "flyOutStyle", "isCloseable", "isExpanded", "isLight", "portalId", "style"]);
        var targetProps = lodash_1.default.first(lodash_1.default.map((0, component_types_1.findTypes)(this.props, ToolTip.Target), 'props'));
        var title = lodash_1.default.get(lodash_1.default.first(lodash_1.default.map((0, component_types_1.findTypes)(this.props, ToolTip.Title), 'props')), 'children');
        var body = lodash_1.default.get(lodash_1.default.first(lodash_1.default.map((0, component_types_1.findTypes)(this.props, ToolTip.Body), 'props')), 'children');
        var getAlignmentOffset = function (n) {
            return alignment === ContextMenu_1.default.CENTER
                ? 0
                : alignment === ContextMenu_1.default.START
                    ? n / 2 - 22.5
                    : -(n / 2 - 22.5);
        };
        return (react_1.default.createElement(ContextMenu_1.default, __assign({ className: cx('&', className), 
            // WARNING: Alignment is always set to center because the getAlignmentOffset function
            // handles the alignment instead of delegating to ContextMenu
            alignment: ContextMenu_1.default.CENTER, direction: direction, directonOffset: 15, getAlignmentOffset: getAlignmentOffset, isExpanded: isExpanded, style: style, portalId: portalId }, (0, lodash_1.omit)(passThroughs, exports.nonPassThroughs), { onMouseOver: this.handleMouseOverTarget, onMouseOut: this.handleMouseOutTarget }),
            react_1.default.createElement(Target, __assign({}, targetProps, { className: cx(lodash_1.default.get(targetProps, 'className'), '&-Target') }), lodash_1.default.get(targetProps, 'children')),
            react_1.default.createElement(FlyOut, { style: __assign(__assign({}, flyOutStyle), { maxWidth: flyOutMaxWidth || (flyOutStyle && flyOutStyle.maxWidth) || 200 }), className: flyOutCx(className, '&', "&-".concat(direction), "&-".concat(alignment), isLight ? '&-light' : '&-default'), onMouseOver: this.handleMouseOverFlyout, onMouseOut: this.handleMouseOutFlyout },
                isCloseable ? (react_1.default.createElement(CloseIcon_1.default, { isClickable: true, size: 8, onClick: this.handleClose, className: flyOutCx('&-close') })) : null,
                !lodash_1.default.isNil(title) ? (react_1.default.createElement("h2", { className: flyOutCx('&-Title') }, title)) : null,
                body)));
    };
    ToolTip.displayName = 'ToolTip';
    ToolTip.Title = ToolTipTitle;
    ToolTip.Target = ToolTipTarget;
    ToolTip.Body = ToolTipBody;
    ToolTip.peek = {
        description: "A utility component that creates a transient message anchored to another component.",
        notes: {
            overview: "A text popup shown on hover.",
            intendedUse: "\n\t\t\t\t\tUse to provide an explanation for a button, text, or an operation. Often used in conjunction with `HelpIcon`.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t**Styling notes**\n\t\t\t\t\t\n\t\t\t\t\t- Use the {direction} and {alignment} that best suit your layout.\n\t\t\t\t\t- Tooltip should typically not use a Title. If one does, it should fit on a single line and not wrap.\n\t\t\t\t\t- Use black tooltips in most interactions. White tooltips are reserved for use within charts, for example `LineChart`.\n\t\t\t\t",
            technicalRecommendations: "\n\t\t\t\t",
        },
        categories: ['communication'],
        madeFrom: ['ContextMenu'],
    };
    ToolTip.reducers = reducers;
    ToolTip.propTypes = {
        /**
         * \`children\` should include exactly one ToolTip.Target and one ToolTip.FlyOut.
         */
        children: node,
        /**
         * Appended to the component-specific class names set on the root element.
         */
        className: string,
        /**
         * Set this to \`true\` if you want to have a \`x\` close icon.
         */
        isCloseable: bool,
        /**
         * Offers a lighter style for the tooltip window. Defaults to false.
         */
        isLight: bool,
        /**
         * Called when the user closes the \`Banner\`.
         * Signature: \`({ event, props }) => {}\`
         */
        onClose: func,
        /** Passed through to the root target element.*/
        style: object,
        /** Passed through to the root FlyOut element.*/
        flyOutStyle: object,
        /**
         * maximum width of the ToolTip FlyOut. Defaults to 200px.
         */
        flyOutMaxWidth: oneOfType([number, string]),
        /**
         * direction of the FlyOut relative to Target.
         */
        direction: oneOf(['down', 'up', 'right', 'left']),
        /**
         * alignment of the Flyout relative to Target in the cross axis from \`direction\`.
         */
        alignment: oneOf(['start', 'center', 'end']),
        /**
         * Indicates whether the ToolTip will render or not.
         */
        isExpanded: bool,
        /**
         * Called when cursor moves over the target
         * Signature: \`({ props, event }) => {}\`
         */
        onMouseOver: func,
        /**
         * Called when cursor leaves the target and the ToolTip
         * Signature: \`({ props, event }) => {}\`
         */
        onMouseOut: func,
        /**
         * The \`id\` of the FlyOut portal element that is appended to \`document.body\`.
         * Defaults to a generated \`id\`.
         */
        portalId: string,
        /**
         * Tooltips do not typically have a Title but one can be displayed above the Body.
         */
        Title: node,
        /**
         * The body of the 'ToolTip'.
         */
        Body: node,
        /**
         * The hover target that will trigger the ToolTip to be displayed.
         */
        Target: node,
    };
    ToolTip.defaultProps = {
        alignment: ContextMenu_1.default.CENTER,
        direction: ContextMenu_1.default.UP,
        flyOutStyle: {},
        isCloseable: false,
        isExpanded: false,
        isLight: false,
        onClose: lodash_1.default.noop,
        onMouseOut: lodash_1.default.noop,
        onMouseOver: lodash_1.default.noop,
        portalId: null,
    };
    return ToolTip;
}(react_1.default.Component));
exports.ToolTipDumb = ToolTip;
exports.default = (0, state_management_1.buildModernHybridComponent)(ToolTip, { reducers: reducers });
//# sourceMappingURL=ToolTip.js.map