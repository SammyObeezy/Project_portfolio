"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lines = void 0;
var lodash_1 = __importDefault(require("lodash"));
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var d3Shape = __importStar(require("d3-shape"));
var style_helpers_1 = require("../../util/style-helpers");
var chart_helpers_1 = require("../../util/chart-helpers");
var chartConstants = __importStar(require("../../constants/charts"));
var Line_1 = __importDefault(require("../Line/Line"));
var cx = style_helpers_1.lucidClassNames.bind('&-Lines');
var arrayOf = prop_types_1.default.arrayOf, func = prop_types_1.default.func, number = prop_types_1.default.number, object = prop_types_1.default.object, bool = prop_types_1.default.bool, string = prop_types_1.default.string;
var isUniform = function (array) {
    return lodash_1.default.every(array, function (val) { return val === lodash_1.default.first(array); });
};
var defaultProps = {
    xField: 'x',
    yFields: ['y'],
    isStacked: false,
    colorOffset: 0,
    palette: chartConstants.PALETTE_7,
};
var Lines = function (props) {
    var className = props.className, data = props.data, isStacked = props.isStacked, palette = props.palette, colorMap = props.colorMap, colorOffset = props.colorOffset, xScale = props.xScale, xField = props.xField, yFields = props.yFields, yScaleOriginal = props.yScale, yStackedMax = props.yStackedMax, passThroughs = __rest(props, ["className", "data", "isStacked", "palette", "colorMap", "colorOffset", "xScale", "xField", "yFields", "yScale", "yStackedMax"]);
    // Copy the original so we can mutate it
    var yScale = yScaleOriginal.copy();
    // If we are stacked, we need to calculate a new domain based on the sum of
    // the various series' y data. One row per series.
    var transformedData = isStacked
        ? d3Shape.stack().keys(yFields)(data)
        : (0, chart_helpers_1.groupByFields)(data, yFields);
    var stackedArea = d3Shape
        .area()
        .defined(function (a) { return lodash_1.default.isFinite(a[0]) && lodash_1.default.isFinite(a[1]); })
        .x(function (a, i) { return xScale(data[i][xField]); })
        .y0(function (a) { return yScale(a[1]); })
        .y1(function (a) { return yScale(a[0]); });
    var area = d3Shape
        .area()
        .defined(function (a) { return lodash_1.default.isFinite(a) || lodash_1.default.isDate(a); })
        .x(function (a, i) { return xScale(data[i][xField]); })
        .y(function (a, i) { return yScale(a); });
    // If we are stacked, we need to calculate a new domain based on the sum of
    // the various group's y data
    if (isStacked) {
        yScale.domain([
            yScale.domain()[0],
            yStackedMax || lodash_1.default.max(lodash_1.default.flatten(lodash_1.default.last(transformedData))),
        ]);
    }
    return (react_1.default.createElement("g", __assign({}, passThroughs, { className: cx(className, '&') }), lodash_1.default.map(transformedData, function (d, dIndex) { return (react_1.default.createElement("g", { key: dIndex },
        react_1.default.createElement(Line_1.default, { color: lodash_1.default.get(colorMap, yFields[dIndex], palette[(dIndex + colorOffset) % palette.length]), d: (isStacked ? stackedArea(d) : area(d)), 
            // Fixes a bug in chrome by forcing a reflow of the element (ANXR-1405)
            style: isUniform(d) ? { transform: 'scaleX(0.999)' } : undefined }))); })));
};
exports.Lines = Lines;
exports.Lines.defaultProps = defaultProps;
exports.Lines.displayName = 'Lines';
exports.Lines.peek = {
    description: "*For use within an `svg`*. A `Line` is typically used to represent continuous data and can be stacked.",
    categories: ['visualizations', 'chart primitives'],
    madeFrom: ['Line'],
};
exports.Lines.propTypes = {
    /**
        Appended to the component-specific class names set on the root element.
    */
    className: string,
    /**
        Top
    */
    top: number,
    /**
        Left
    */
    left: number,
    /**
        Takes one of the palettes exported from \`lucid.chartConstants\`.
        Available palettes:

        - \`PALETTE_7\` (default)
        - \`PALETTE_30\`
        - \`PALETTE_MONOCHROME_0_5\`
        - \`PALETTE_MONOCHROME_1_5\`
        - \`PALETTE_MONOCHROME_2_5\`
        - \`PALETTE_MONOCHROME_3_5\`
        - \`PALETTE_MONOCHROME_4_5\`
        - \`PALETTE_MONOCHROME_5_5\`
        - \`PALETTE_MONOCHROME_6_5\`
    */
    palette: arrayOf(string),
    /**
        You can pass in an object if you want to map fields to
        \`lucid.chartConstants\` or custom colors:

            {
                'imps': COLOR_0,
                'rev': COLOR_3,
                'clicks': '#abc123',
            }
    */
    colorMap: object,
    /**
        De-normalized data, e.g.

            [
                { x: 'one'   , y: 1 },
                { x: 'two'   , y: 2 },
                { x: 'three' , y: 2 },
                { x: 'four'  , y: 3 },
                { x: 'five'  , y: 4 },
            ]


        Or (be sure to set \`yFields\` to \`['y0', 'y1', 'y2', 'y3']\`)

            [
                { x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },
                { x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },
                { x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },
                { x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },
                { x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },
                { x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },
            ]
    */
    data: arrayOf(object).isRequired,
    /**
        The scale for the x axis. Must be a d3 scale. Lucid exposes the
        \`lucid.d3Scale\` library for use here.
    */
    xScale: func.isRequired,
    /**
        The scale for the y axis. Must be a d3 scale. Lucid exposes the
        \`lucid.d3Scale\` library for use here.
    */
    yScale: func.isRequired,
    /**
        Typically this number can be derived from the yScale. However when we're
        \`isStacked\` we need to calculate a new domain for the yScale based on
        the sum of the data. If you need explicit control of the y max when
        stacking, pass it in here.
    */
    yStackedMax: number,
    /**
        The field we should look up your x data by.
    */
    xField: string,
    /**
        The field(s) we should look up your y data by. Each entry represents a
        series. Your actual y data should be numeric.
    */
    yFields: arrayOf(string),
    /**
        This will stack the data instead of grouping it. In order to stack the
        data we have to calculate a new domain for the y scale that is based on
        the \`sum\` of the data.
    */
    isStacked: bool,
    /**
        Sometimes you might not want the colors to start rotating at the blue
        color, this number will be added the line index in determining which
        color the lines are.
    */
    colorOffset: number,
};
exports.default = exports.Lines;
//# sourceMappingURL=Lines.js.map