"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionGroup = exports.NullOption = exports.DropMenuDumb = void 0;
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var lodash_1 = __importDefault(require("lodash"));
var style_helpers_1 = require("../../util/style-helpers");
var component_types_1 = require("../../util/component-types");
var dom_helpers_1 = require("../../util/dom-helpers");
var state_management_1 = require("../../util/state-management");
var KEYCODE = __importStar(require("../../constants/key-code"));
var reducers = __importStar(require("./DropMenu.reducers"));
var ContextMenu_1 = __importDefault(require("../ContextMenu/ContextMenu"));
function joinArray(array, getSeparator) {
    return lodash_1.default.reduce(array, function (newArray, element, index) {
        newArray.push(element);
        if (index < lodash_1.default.size(array) - 1) {
            newArray.push(getSeparator(element, index, array));
        }
        return newArray;
    }, []);
}
function isOptionVisible(option) {
    return !option.optionProps.isHidden;
}
var cx = style_helpers_1.lucidClassNames.bind('&-DropMenu');
var any = prop_types_1.default.any, arrayOf = prop_types_1.default.arrayOf, bool = prop_types_1.default.bool, func = prop_types_1.default.func, node = prop_types_1.default.node, number = prop_types_1.default.number, object = prop_types_1.default.object, oneOf = prop_types_1.default.oneOf, string = prop_types_1.default.string;
var Header = function (_props) { return null; };
Header.displayName = 'DropMenu.Header';
Header.peek = {
    description: "\n\t\tAn optional header to be displayed within the expanded Flyout,\n\t\tabove all `Option`s.\n\t",
};
Header.propName = 'Header';
Header.propTypes = {};
var Control = function (_props) { return null; };
Control.displayName = 'DropMenu.Control';
Control.peek = {
    description: "Renders a `<div>` that acts as the control target which the flyout menu is anchored to. Only one `Control` is used.",
};
Control.propName = 'Control';
Control.propTypes = {};
var OptionGroup = function (_props) { return null; };
exports.OptionGroup = OptionGroup;
OptionGroup.displayName = 'DropMenu.OptionGroup';
OptionGroup.peek = {
    description: "A special kind of `Option` that is always rendered at the top of the menu and has an `optionIndex` of `null`. Useful for unselect.",
};
OptionGroup.propName = 'OptionGroup';
OptionGroup.propTypes = {
    /**
        hides the \`OptionGroup\` from the list.
    */
    isHidden: bool,
};
OptionGroup.defaultProps = {
    isHidden: false,
};
var Option = function (_props) { return null; };
Option.displayName = 'DropMenu.Option';
Option.peek = {
    description: "\n\t\tRenders a `<div>` that acts as an option in the menu.\n\t",
};
Option.propName = 'Option';
Option.propTypes = {
    /**
        disables selection of the \`Option\`.
    */
    isDisabled: bool,
    /**
        hides the \`Option\` from the list.
    */
    isHidden: bool,
    /**
        controls wrapping of the text.
    */
    isWrapped: bool,
};
Option.defaultProps = {
    isDisabled: false,
    isHidden: false,
    isWrapped: true,
};
var NullOption = function (_props) { return null; };
exports.NullOption = NullOption;
NullOption.displayName = 'DropMenu.NullOption';
NullOption.peek = {
    description: "A special kind of `Option` that is always rendered at the top of the menu and has an `optionIndex` of `null` used for deselecting.",
};
NullOption.propName = 'NullOption';
NullOption.propTypes = {};
var FixedOption = function (_props) { return null; };
FixedOption.displayName = 'DropMenu.FixedOption';
FixedOption.peek = {
    description: "\n\t\tA special kind of `Option` that is always rendered at the top of\n\t\tthe menu.\n\t",
};
FixedOption.propName = 'FixedOption';
FixedOption.propTypes = {
    /**
        disables selection of the \`Option\`.
    */
    isDisabled: bool,
    /**
        hides the \`Option\` from the list.
    */
    isHidden: bool,
    /**
        controls wrapping of the text.
    */
    isWrapped: bool,
};
FixedOption.defaultProps = {
    isDisabled: false,
    isHidden: false,
    isWrapped: true,
};
var DropMenuContextMenu = function (_props) { return null; };
DropMenuContextMenu.displayName = 'DropMenu.ContextMenu';
DropMenuContextMenu.peek = {
    description: "Props that are passed through to the underlying ContextMenu.",
};
DropMenuContextMenu.propName = 'ContextMenu';
DropMenuContextMenu.propTypes = {
    children: node /**/,
};
/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */
var nonPassThroughs = [
    'children',
    'className',
    'style',
    'isDisabled',
    'isExpanded',
    'direction',
    'alignment',
    'selectedIndices',
    'focusedIndex',
    'portalId',
    'flyOutStyle',
    'optionContainerStyle',
    'onExpand',
    'onCollapse',
    'onSelect',
    'onFocusNext',
    'onFocusPrev',
    'onFocusOption',
    'Control',
    'Option',
    'OptionGroup',
    'NullOption',
    'Header',
    'ContextMenu',
    'FixedOption',
    'initialState',
    'callbackId',
];
var DropMenu = /** @class */ (function (_super) {
    __extends(DropMenu, _super);
    function DropMenu(props) {
        var _this = _super.call(this, props) || this;
        _this.getPreprocessedOptionData = function (props) {
            return DropMenu.preprocessOptionData(props, DropMenu);
        };
        _this.handleKeydown = function (event) {
            var _a = _this, props = _a.props, _b = _a.props, isExpanded = _b.isExpanded, focusedIndex = _b.focusedIndex, onExpand = _b.onExpand, onCollapse = _b.onCollapse, onSelect = _b.onSelect, onFocusOption = _b.onFocusOption;
            var _c = _this.state, flattenedOptionsData = _c.flattenedOptionsData, nullOptions = _c.nullOptions;
            _this.setState({
                isMouseTriggered: false,
            });
            if (isExpanded) {
                if (event.keyCode === KEYCODE.Enter) {
                    event.preventDefault();
                    var focusedOptionData = lodash_1.default.get(flattenedOptionsData, lodash_1.default.isNil(focusedIndex) ? '' : focusedIndex, null);
                    var focusedOptionProps = lodash_1.default.get(focusedOptionData, 'optionProps', Option.defaultProps);
                    if (focusedOptionData && !focusedOptionProps.isDisabled) {
                        onSelect &&
                            onSelect(focusedIndex, { props: focusedOptionProps, event: event });
                    }
                    else if (lodash_1.default.isNull(focusedIndex)) {
                        onSelect && onSelect(null, { props: lodash_1.default.first(nullOptions), event: event });
                    }
                }
                if (event.keyCode === KEYCODE.Escape) {
                    event.preventDefault();
                    onCollapse && onCollapse({ props: props, event: event });
                }
                if (event.keyCode === KEYCODE.ArrowUp) {
                    if (lodash_1.default.isNumber(focusedIndex) || lodash_1.default.isNull(focusedIndex)) {
                        if (focusedIndex === 0) {
                            if (!lodash_1.default.isEmpty(nullOptions)) {
                                event.preventDefault();
                                onFocusOption && onFocusOption(null, { props: props, event: event });
                            }
                        }
                        if (!lodash_1.default.isNil(focusedIndex) && focusedIndex > 0) {
                            event.preventDefault();
                            onFocusOption &&
                                onFocusOption(lodash_1.default.findLastIndex(flattenedOptionsData, isOptionVisible, focusedIndex - 1), { props: props, event: event });
                        }
                    }
                    else {
                        event.preventDefault();
                        focusedIndex &&
                            onFocusOption &&
                            onFocusOption(lodash_1.default.findLastIndex(flattenedOptionsData, isOptionVisible, focusedIndex - 1), { props: props, event: event });
                    }
                }
                if (event.keyCode === KEYCODE.ArrowDown) {
                    if (lodash_1.default.isNumber(focusedIndex)) {
                        if (focusedIndex < lodash_1.default.size(flattenedOptionsData) - 1) {
                            event.preventDefault();
                            onFocusOption &&
                                onFocusOption(lodash_1.default.findIndex(flattenedOptionsData, isOptionVisible, focusedIndex + 1), { props: props, event: event });
                        }
                    }
                    else {
                        event.preventDefault();
                        onFocusOption &&
                            onFocusOption(lodash_1.default.findIndex(flattenedOptionsData, isOptionVisible, !lodash_1.default.isNil(focusedIndex) ? focusedIndex : undefined), { props: props, event: event });
                    }
                }
            }
            else {
                if (event.keyCode === KEYCODE.ArrowDown) {
                    event.preventDefault();
                    onExpand && onExpand({ props: props, event: event });
                }
            }
        };
        _this.handleClick = function (event) {
            var _a = _this, props = _a.props, _b = _a.props, isExpanded = _b.isExpanded, onExpand = _b.onExpand, onCollapse = _b.onCollapse;
            if (isExpanded) {
                onCollapse && onCollapse({ props: props, event: event });
            }
            else {
                onExpand && onExpand({ props: props, event: event });
            }
        };
        _this.handleMouseFocusOption = function (optionIndex, optionProps, event) {
            var _a = _this.props, focusedIndex = _a.focusedIndex, onFocusOption = _a.onFocusOption;
            _this.setState({
                isMouseTriggered: true,
            });
            if (!optionProps.isDisabled && focusedIndex !== optionIndex) {
                onFocusOption && onFocusOption(optionIndex, { props: _this.props, event: event });
            }
        };
        _this.handleSelectOption = function (optionIndex, optionProps, event) {
            var onSelect = _this.props.onSelect;
            if (!optionProps.isDisabled) {
                onSelect && onSelect(optionIndex, { props: optionProps, event: event });
            }
        };
        _this.renderOption = function (optionProps, optionIndex, isGrouped) {
            if (isGrouped === void 0) { isGrouped = false; }
            var _a = _this.props, selectedIndices = _a.selectedIndices, focusedIndex = _a.focusedIndex;
            var isMouseTriggered = _this.state.isMouseTriggered;
            var isDisabled = optionProps.isDisabled, isHidden = optionProps.isHidden, isWrapped = optionProps.isWrapped;
            var isFocused = optionIndex === focusedIndex;
            var isSelected = lodash_1.default.includes(selectedIndices, optionIndex);
            return isHidden ? null : (react_1.default.createElement("div", __assign({ key: 'DropMenuOption' + optionIndex }, lodash_1.default.omit(optionProps, [
                'isDisabled',
                'isHidden',
                'isWrapped',
                'Selected',
                'Selection',
                'initialState',
                'callbackId',
            ]), { onClick: function (event) {
                    return _this.handleSelectOption(optionIndex, optionProps, event);
                }, onMouseMove: function (event) {
                    return _this.handleMouseFocusOption(optionIndex, optionProps, event);
                }, className: cx('&-Option', {
                    '&-Option-is-grouped': isGrouped,
                    '&-Option-is-focused': isFocused,
                    '&-Option-is-selected': isSelected,
                    '&-Option-is-disabled': isDisabled,
                    '&-Option-is-null': lodash_1.default.isNull(optionIndex),
                    '&-Option-is-wrapped': isWrapped,
                }, optionProps.className), ref: function (optionHTMLElement) {
                    if (isFocused && !isMouseTriggered) {
                        (0, dom_helpers_1.scrollParentTo)(optionHTMLElement, _this._header && _this._header.current
                            ? _this._header.current.offsetHeight
                            : undefined);
                    }
                } })));
        };
        _this.UNSAFE_componentWillReceiveProps = function (nextProps) {
            // only preprocess options data when it changes (via new props) - better performance than doing this each render
            _this.setState(_this.getPreprocessedOptionData(nextProps));
        };
        _this.state = __assign({ optionGroups: [], flattenedOptionsData: [], ungroupedOptionData: [], optionGroupDataLookup: {}, nullOptions: [], fixedOptionData: [], isMouseTriggered: false, portalId: _this.props.portalId || (0, style_helpers_1.uniqueName)('DropMenu-Portal-'), isExpanded: false, focusedIndex: null, optionGroupIndex: null, optionProps: [], selectedIndices: [] }, _this.getPreprocessedOptionData(props));
        _this._header = react_1.default.createRef();
        return _this;
    }
    DropMenu.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, style = _a.style, isDisabled = _a.isDisabled, isExpanded = _a.isExpanded, direction = _a.direction, alignment = _a.alignment, onCollapse = _a.onCollapse, flyOutStyle = _a.flyOutStyle, optionContainerStyle = _a.optionContainerStyle, passThroughs = __rest(_a, ["className", "style", "isDisabled", "isExpanded", "direction", "alignment", "onCollapse", "flyOutStyle", "optionContainerStyle"]);
        var _b = this.state, optionGroups = _b.optionGroups, fixedOptionData = _b.fixedOptionData, ungroupedOptionData = _b.ungroupedOptionData, optionGroupDataLookup = _b.optionGroupDataLookup, nullOptions = _b.nullOptions, portalId = _b.portalId;
        var contextMenuProps = lodash_1.default.get((0, component_types_1.getFirst)(this.props, DropMenu.ContextMenu), 'props', {});
        var controlProps = lodash_1.default.get((0, component_types_1.getFirst)(this.props, DropMenu.Control), 'props', {});
        var headerProps = lodash_1.default.get((0, component_types_1.getFirst)(this.props, DropMenu.Header), 'props', {});
        return (react_1.default.createElement("div", __assign({ className: cx('&', '&-base', {
                '&-is-expanded': isExpanded,
                '&-direction-down': isExpanded && direction === 'down',
                '&-direction-up': isExpanded && direction === 'up',
            }, className), style: style }, lodash_1.default.omit(passThroughs, nonPassThroughs)),
            react_1.default.createElement(ContextMenu_1.default, __assign({}, contextMenuProps, { portalId: portalId, isExpanded: isExpanded, direction: direction, alignment: alignment, onClickOut: onCollapse }),
                react_1.default.createElement(ContextMenu_1.default.Target, null,
                    react_1.default.createElement("div", __assign({}, (!isDisabled
                        ? {
                            tabIndex: 0,
                            onClick: this.handleClick,
                            onKeyDown: this.handleKeydown,
                        }
                        : null), controlProps, { className: cx('&-Control', lodash_1.default.get(controlProps, 'className')) }))),
                react_1.default.createElement(ContextMenu_1.default.FlyOut, { className: cx('&', className), style: flyOutStyle },
                    !lodash_1.default.isEmpty(headerProps) && (react_1.default.createElement("div", __assign({}, headerProps, { className: cx('&-Header', headerProps.className), onKeyDown: this.handleKeydown, ref: this._header }))),
                    react_1.default.createElement("div", { className: cx('&-option-container'), style: lodash_1.default.assign({}, flyOutStyle, optionContainerStyle) },
                        lodash_1.default.map(nullOptions, function (optionProps) {
                            return _this.renderOption(optionProps, null);
                        }).concat(lodash_1.default.isEmpty(nullOptions)
                            ? []
                            : [
                                react_1.default.createElement("div", { key: 'OptionGroup-divider-NullOption', className: cx('&-OptionGroup-divider') }),
                            ]),
                        // fixed options go first
                        lodash_1.default.map(fixedOptionData, function (_a) {
                            var optionProps = _a.optionProps, optionIndex = _a.optionIndex;
                            return _this.renderOption(optionProps, optionIndex);
                        }),
                        joinArray(
                        // for each option group,
                        lodash_1.default.map(optionGroups, function (optionGroupProps, optionGroupIndex) {
                            var groupedOptions = optionGroupDataLookup[optionGroupIndex];
                            if (optionGroupProps.isHidden ||
                                lodash_1.default.every(groupedOptions, {
                                    optionProps: { isHidden: true },
                                })) {
                                return null;
                            }
                            var labelElements = (0, component_types_1.rejectTypes)(optionGroupProps.children, [
                                DropMenu.Control,
                                DropMenu.OptionGroup,
                                DropMenu.Option,
                                DropMenu.NullOption,
                            ]);
                            // render label if there is one
                            return (lodash_1.default.isEmpty(labelElements)
                                ? []
                                : [
                                    react_1.default.createElement("div", __assign({}, lodash_1.default.omit(optionGroupProps, [
                                        'isHidden',
                                        'initialState',
                                        'callbackId',
                                    ]), { key: 'OptionGroup-label' + optionGroupIndex, className: cx('&-label', optionGroupProps.className) }), labelElements),
                                    // render the options in the group
                                ]).concat(lodash_1.default.map(optionGroupDataLookup[optionGroupIndex], function (_a) {
                                var optionProps = _a.optionProps, optionIndex = _a.optionIndex;
                                return _this.renderOption(optionProps, optionIndex, true);
                            }));
                            // append all ungrouped options as another unlabeled group
                        }).concat(lodash_1.default.isEmpty(ungroupedOptionData)
                            ? []
                            : [
                                lodash_1.default.map(ungroupedOptionData, function (_a) {
                                    var optionProps = _a.optionProps, optionIndex = _a.optionIndex;
                                    return _this.renderOption(optionProps, optionIndex);
                                }),
                            ]), function (element, index) {
                            return element && (react_1.default.createElement("div", { key: "OptionGroup-divider-".concat(index), className: cx('&-OptionGroup-divider') }));
                        } // separate each group with divider
                        ))))));
    };
    DropMenu.displayName = 'DropMenu';
    DropMenu.ContextMenu = DropMenuContextMenu;
    DropMenu.FixedOption = FixedOption;
    DropMenu.NullOption = NullOption;
    DropMenu.Option = Option;
    DropMenu.OptionGroup = OptionGroup;
    DropMenu.Control = Control;
    DropMenu.Header = Header;
    DropMenu.peek = {
        ContextMenu: DropMenuContextMenu,
        description: "`DropMenu` is a helper component used to render a menu of options attached to any control. Supports option groups with and without labels as well as special options with a `null` index for unselect.",
        categories: ['helpers'],
        madeFrom: ['ContextMenu'],
    };
    DropMenu.reducers = reducers;
    DropMenu.propTypes = {
        /**
            Should be instances of: \`DropMenu.Control\`, \`DropMenu.Option\`,
            \`DropMenu.OptionGroup\`, \`DropMenu.Nulloption\`. Other direct child
            elements will not render.
        */
        children: node,
        className: string /**
            Appended to the component-specific class names set on the root elements.
            Applies to *both* the control and the flyout menu.
        */,
        /**
            Styles that are passed through to root element.
        */
        style: object,
        /**
            Disables the DropMenu from being clicked or focused.
        */
        isDisabled: bool,
        /**
            Renders the flyout menu adjacent to the control.
        */
        isExpanded: bool,
        /**
            Sets the direction the flyout menu will render relative to the control.
        */
        direction: oneOf(['down', 'up']),
        /**
            Sets the alignment the flyout menu will render relative to the control.
        */
        alignment: oneOf(['start', 'center', 'end']),
        /**
            An array of currently selected \`DropMenu.Option\` indices.
        */
        selectedIndices: arrayOf(number),
        /**
            The currently focused index of \`DropMenu.Option\`. Can also be \`null\`.
        */
        focusedIndex: number,
        /**
            The \`id\` of the flyout menu portal element that is appended to
            \`document.body\`. Defaults to a generated id.
        */
        portalId: string,
        /**
            Styles that are passed through to the ContextMenu FlyOut element.
        */
        flyOutStyle: object,
        /**
            Styles that are passed through to the option container element.
        */
        optionContainerStyle: object,
        /**
            Called when collapsed and the control is clicked, or when the control has
            focus and the Down Arrow is pressed.  Has the signature
            \`({ props, event }) => {}\`
        */
        onExpand: func,
        /**
            Called when expanded and the user clicks the control or outside of the
            menu, or when the control has focus and the Escape key is pressed Has the
            signature \`({ props, event }) => {}\`
        */
        onCollapse: func,
        /**
            Called when an option is clicked, or when an option has focus and the
            Enter key is pressed.  Has the signature
            \`(optionIndex, {props, event}) => {}\`
            where optionIndex can be a number or \`null\`.
        */
        onSelect: func,
        /**
            Called when expanded and the the Down Arrow key is pressed. Not called
            when focus is on the last option.  Has the signature
            \`({ props, event }) => {}\`
        */
        onFocusNext: func,
        /**
            Called when expanded and the the Up Arrow key is pressed. Not called when
            focus is on the first option.  Has the signature
            \`({ props, event }) => {}\`
        */
        onFocusPrev: func,
        /**
            Called when the mouse moves over an option.  Has the signature
            \`(optionIndex) => {}\` where optionIndex can be a number or \`null\`.
        */
        onFocusOption: func,
        Control: any /**
            *Child Element* - The control target which the flyout menu is anchored
            to. Only one \`Control\` is used.
        */,
        Option: any /**
            *Child Element* - These are menu options. The \`optionIndex\` is in-order
            of rendering regardless of group nesting, starting with index \`0\`.
            Each \`Option\` may be passed a prop called \`isDisabled\` to disable
            selection of that \`Option\`.  Any other props pass to Option will be
            available from the \`onSelect\` handler.
        */,
        OptionGroup: any /**
            *Child Element* - Used to group \`Option\`s within the menu. Any
            non-\`Option\`s passed in will be rendered as a label for the group.
        */,
        NullOption: any /**
            *Child Element* - A special kind of \`Option\` that is always rendered at
            the top of the menu and has an \`optionIndex\` of \`null\`. Useful for
            unselect.
        */,
        Header: any /**
            *Child Element* - An optional header to be displayed within the expanded
            Flyout, above all \`Option\`s.
        */,
        ContextMenu: any /**
            *Child Element* - props pass through to the underlying ContextMenu
            component
        */,
        FixedOption: any /**
            *Child Element* - A special kind of \`Option\` that is always rendered at the top of
            the menu.
        */,
    };
    DropMenu.defaultProps = {
        isDisabled: false,
        isExpanded: false,
        direction: 'down',
        alignment: 'start',
        selectedIndices: [],
        focusedIndex: null,
        flyOutStyle: { maxHeight: '18em' },
        onExpand: lodash_1.default.noop,
        onCollapse: lodash_1.default.noop,
        onSelect: lodash_1.default.noop,
        onFocusNext: lodash_1.default.noop,
        onFocusPrev: lodash_1.default.noop,
        onFocusOption: lodash_1.default.noop,
        portalId: '',
        optionContainerStyle: {},
        ContextMenu: ContextMenu_1.default.defaultProps,
    };
    DropMenu.preprocessOptionData = function (props, ParentType) {
        var OptionGroup = ParentType.OptionGroup, Option = ParentType.Option, NullOption = ParentType.NullOption, FixedOption = ParentType.FixedOption;
        var optionGroups = lodash_1.default.map((0, component_types_1.findTypes)(props, OptionGroup), 'props'); // find all OptionGroup props
        var fixedOptions = lodash_1.default.map((0, component_types_1.findTypes)(props, FixedOption), 'props'); // find all FixedOption props
        var ungroupedOptions = lodash_1.default.map((0, component_types_1.findTypes)(props, Option), 'props'); // find all ungrouped Option props
        var nullOptions = NullOption
            ? lodash_1.default.map((0, component_types_1.findTypes)(props, NullOption), 'props')
            : []; // find all NullOption props
        var fixedOptionData = lodash_1.default.map(fixedOptions, function (optionProps, localOptionIndex) {
            return {
                localOptionIndex: localOptionIndex,
                optionIndex: localOptionIndex,
                optionGroupIndex: null,
                optionProps: optionProps,
            };
        });
        // flatten grouped options into array of objects to associate { index, group index, and props } for each option
        var groupedOptionData = lodash_1.default.reduce(optionGroups, function (memo, optionGroupProps, optionGroupIndex) {
            var groupedOptions = lodash_1.default.map((0, component_types_1.findTypes)(optionGroupProps, Option), 'props'); // find all Option props for current group
            return memo.concat(lodash_1.default.map(groupedOptions, function (optionProps, localOptionIndex) {
                return {
                    localOptionIndex: localOptionIndex,
                    optionIndex: lodash_1.default.size(memo) + lodash_1.default.size(fixedOptionData) + localOptionIndex,
                    optionGroupIndex: optionGroupIndex,
                    optionProps: __assign({ isHidden: false }, optionProps),
                };
            }));
        }, []);
        // create lookup object for options by their group index
        var optionGroupDataLookup = lodash_1.default.groupBy(groupedOptionData, 'optionGroupIndex');
        // store ungrouped options into array of objects to associate { index, and props } for each option
        var ungroupedOptionData = lodash_1.default.map(ungroupedOptions, function (optionProps, localOptionIndex) {
            return {
                localOptionIndex: localOptionIndex,
                optionIndex: lodash_1.default.size(groupedOptionData) +
                    lodash_1.default.size(fixedOptionData) +
                    localOptionIndex,
                optionGroupIndex: null,
                optionProps: __assign({ isHidden: false }, optionProps),
            };
        });
        // concatenate grouped options array with ungrouped options array to get flat list of all options
        var flattenedOptionsData = lodash_1.default.concat(fixedOptionData, groupedOptionData, ungroupedOptionData);
        return {
            optionGroups: optionGroups,
            optionGroupDataLookup: optionGroupDataLookup,
            fixedOptionData: fixedOptionData,
            ungroupedOptionData: ungroupedOptionData,
            flattenedOptionsData: flattenedOptionsData,
            nullOptions: nullOptions,
        };
    };
    return DropMenu;
}(react_1.default.Component));
exports.DropMenuDumb = DropMenu;
exports.default = (0, state_management_1.buildModernHybridComponent)(DropMenu, { reducers: reducers });
//# sourceMappingURL=DropMenu.js.map