"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDate = exports.transformFromCenter = exports.discreteTicks = exports.maxByFieldsStacked = exports.maxByFields = exports.minByFields = exports.nearest = exports.byFields = exports.groupByFields = exports.extractFields = exports.stackByFields = void 0;
var lodash_1 = __importDefault(require("lodash"));
var d3TimeFormat = __importStar(require("d3-time-format"));
var d3Time = __importStar(require("d3-time"));
/**
 * stackByFields
 *
 * D3's `stack` groups each series' data together but we sometimes we want the
 * stacked groups to remain grouped as in the original normalized data. This
 * function helps achieve that.
 *
 * @param {object[]} collection - normalized data you want to operate on
 * @param {string[]} fields - fields to pluck off for the y data
 * @return {array[]} - array of arrays, one for row in the original `collection`
 */
function stackByFields(collection, fields) {
    var fieldsArray = lodash_1.default.castArray(fields);
    return lodash_1.default.map(collection, function (d) {
        return lodash_1.default.reduce(fieldsArray, function (acc, field) {
            var dataPoint = lodash_1.default.get(d, field, 0);
            if (lodash_1.default.isEmpty(acc)) {
                return acc.concat([[0, dataPoint]]);
            }
            var maybeLast = lodash_1.default.last(lodash_1.default.last(acc));
            var last = maybeLast === undefined ? 0 : maybeLast;
            return acc.concat([[last, last + dataPoint]]);
        }, []);
    });
}
exports.stackByFields = stackByFields;
/**
 * extractFields
 *
 * This will return the data in a similar format to stackByFields but without
 * the stacking.
 *
 * @param {object[]} collection - normalized data you want to operate on
 * @param {string[]} fields - fields to pluck off for the y data
 * @return {array[]} - array of arrays, one for each field
 */
function extractFields(collection, fields, minDomainValue) {
    if (minDomainValue === void 0) { minDomainValue = 0; }
    var fieldsArray = lodash_1.default.castArray(fields);
    return lodash_1.default.map(collection, function (d) {
        return lodash_1.default.map(fieldsArray, function (field) { return [minDomainValue, lodash_1.default.get(d, field, 0)]; });
    });
}
exports.extractFields = extractFields;
/**
 * groupByFields
 *
 * This will return the data in a similar format to d3Shape.stack
 * but without the stacking of the data.
 *
 * @param {object[]} collection - normalized data you want to operate on
 * @param {string[]} fields - fields to pluck off for the y data
 * @return {array[]} - array of arrays, one for each field
 */
function groupByFields(collection, fields) {
    var fieldsArray = lodash_1.default.castArray(fields);
    return lodash_1.default.map(fieldsArray, function (field) {
        return lodash_1.default.map(collection, field);
    });
}
exports.groupByFields = groupByFields;
/**
 * byFields
 *
 * Takes a collection of data and returns an array of all the fields off that
 * collection.
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {array}
 */
function byFields(collection, fields) {
    var fieldArray = lodash_1.default.castArray(fields);
    return lodash_1.default.reduce(fieldArray, function (acc, field) {
        return acc.concat(lodash_1.default.map(collection, field));
    }, []);
}
exports.byFields = byFields;
/**
 * nearest
 *
 * Divide and conquer algorithm that helps find the nearest element to `value`
 * in `nums`
 *
 * @param {number[]} nums - sorted array of numbers to search through
 * @param {number} value - value you're trying to locate the nearest array element for
 * @return {number} - the nearest array element to the value
 */
function nearest(nums, value) {
    if (nums.length < 2) {
        return lodash_1.default.first(nums);
    }
    if (nums.length === 2) {
        return value > (nums[0] + nums[1]) / 2 ? nums[1] : nums[0];
    }
    var mid = nums.length >>> 1;
    return nums[mid] > value
        ? nearest(nums.slice(0, mid + 1), value)
        : nearest(nums.slice(mid), value);
}
exports.nearest = nearest;
/**
 * minByFields
 *
 * Returns the minimum element from a collection by a set of fields.
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {any}
 */
function minByFields(collection, fields) {
    return lodash_1.default.min(byFields(collection, fields));
}
exports.minByFields = minByFields;
/**
 * maxByFields
 *
 * Returns the maximum element from a collection by a set of fields.
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {any}
 */
function maxByFields(collection, fields) {
    return lodash_1.default.max(byFields(collection, fields));
}
exports.maxByFields = maxByFields;
/**
 * maxByFieldsStacked
 *
 * Returns the max sum of a set of fields from a collection
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {any}
 */
function maxByFieldsStacked(collection, fields) {
    var fieldArray = lodash_1.default.castArray(fields);
    var sums = lodash_1.default.reduce(collection, function (acc, item) {
        return acc.concat(lodash_1.default.sum(lodash_1.default.toArray(lodash_1.default.pick(item, fieldArray))));
    }, []);
    return lodash_1.default.max(sums);
}
exports.maxByFieldsStacked = maxByFieldsStacked;
/**
 * discreteTicks
 *
 * Returns `count` evenly spaced, representative values from the `array`.
 *
 * @param {array} array
 * @param {number} size - should be greater than 1
 * @return {array}
 */
function discreteTicks(array, count) {
    if (count === void 0) { count = null; }
    if (!array || lodash_1.default.isNil(count) || array.length <= count) {
        return array;
    }
    var step = (array.length - 1) / Math.max(1, count - 1);
    return lodash_1.default.reduce(lodash_1.default.times(count), function (acc, n) {
        return acc.concat(array[Math.round(n * step)]);
    }, []);
}
exports.discreteTicks = discreteTicks;
/**
 * transformFromCenter
 *
 * Scaling paths from their center is tricky. This function
 * helps do that be generating a translate/scale transform
 * string with the correct numbers.
 *
 * @param {number} x - the x data point where you want the path to be centered at
 * @param {number} y - the y data point where you want the path to be centered at
 * @param {number} xCenter - the x coordinate of the center of the path you're trying to transform
 * @param {number} yCenter - the x coordinate of the center of the path you're trying to transform
 * @param {number} scale - number to scale to, 2 would be 2x bigger
 * @return {string} - transform string
 */
function transformFromCenter(x, y, xCenter, yCenter, scale) {
    return "translate(".concat((1 - scale) * xCenter + (x - xCenter), ", ").concat((1 - scale) * yCenter + (y - yCenter), ") scale(").concat(scale, ")");
}
exports.transformFromCenter = transformFromCenter;
var FORMAT_MILLISECOND = d3TimeFormat.timeFormat('.%L');
var FORMAT_SECOND = d3TimeFormat.timeFormat(':%S');
var FORMAT_MINUTE = d3TimeFormat.timeFormat('%I:%M');
var FORMAT_HOUR = d3TimeFormat.timeFormat('%I %p');
var FORMAT_DAY = d3TimeFormat.timeFormat('%a %d');
var FORMAT_WEEK = d3TimeFormat.timeFormat('%b %d');
var FORMAT_MONTH = d3TimeFormat.timeFormat('%b');
var FORMAT_YEAR = d3TimeFormat.timeFormat('%Y');
/**
 * formatDate
 *
 * This function was written to be used for tick formatting with d3 time
 * scales.
 *
 * @param {date} date - input date
 * @return {string} - formatted date
 */
function formatDate(date) {
    return (d3Time.timeSecond(date) < date
        ? FORMAT_MILLISECOND
        : d3Time.timeMinute(date) < date
            ? FORMAT_SECOND
            : d3Time.timeHour(date) < date
                ? FORMAT_MINUTE
                : d3Time.timeDay(date) < date
                    ? FORMAT_HOUR
                    : d3Time.timeMonth(date) < date
                        ? d3Time.timeWeek(date) < date
                            ? FORMAT_DAY
                            : FORMAT_WEEK
                        : d3Time.timeYear(date) < date
                            ? FORMAT_MONTH
                            : FORMAT_YEAR)(date);
}
exports.formatDate = formatDate;
//# sourceMappingURL=chart-helpers.js.map