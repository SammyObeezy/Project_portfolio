"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.omitProps = exports.addSpecialOmittedProps = exports.getFirst = exports.createElements = exports.rejectTypes = exports.findTypes = exports.filterTypes = exports.createClass = void 0;
var react_1 = __importDefault(require("react"));
var create_react_class_1 = __importDefault(require("create-react-class"));
var prop_types_1 = __importDefault(require("prop-types"));
var lodash_1 = __importDefault(require("lodash"));
var state_management_1 = require("./state-management");
/**
 * creates a React component
 */
function createClass(spec) {
    var _a = spec._isPrivate, _isPrivate = _a === void 0 ? false : _a, getDefaultProps = spec.getDefaultProps, _b = spec.statics, statics = _b === void 0 ? {} : _b, _c = spec.components, components = _c === void 0 ? {} : _c, _d = spec.reducers, reducers = _d === void 0 ? {} : _d, _e = spec.selectors, selectors = _e === void 0 ? {} : _e, _f = spec.initialState, initialState = _f === void 0 ? getDefaultProps &&
        (0, state_management_1.omitFunctionPropsDeep)(getDefaultProps.apply(spec)) : _f, _g = spec.propName, propName = _g === void 0 ? null : _g, _h = spec.propTypes, propTypes = _h === void 0 ? {} : _h, _j = spec.render, render = _j === void 0 ? function () { return null; } : _j, restDefinition = __rest(spec, ["_isPrivate", "getDefaultProps", "statics", "components", "reducers", "selectors", "initialState", "propName", "propTypes", "render"]);
    var propTypeValidators = __assign(__assign({}, propTypes), lodash_1.default.mapValues(spec.components, function (componentValue, componentKey) {
        return prop_types_1.default.any;
    } /* Props for ${componentValue.displayName || componentKey} */));
    // Intentionally keep this object type inferred so it can be passed to
    // `createReactClass`
    var newDefinition = __assign(__assign({ getDefaultProps: getDefaultProps }, restDefinition), { statics: __assign(__assign(__assign({}, statics), components), { _isPrivate: _isPrivate, reducers: reducers, selectors: selectors, initialState: initialState, propName: propName }), propTypes: propTypeValidators, render: render });
    if (!lodash_1.default.isUndefined(newDefinition.statics)) {
        newDefinition.statics.definition = newDefinition;
    }
    var newClass = (0, create_react_class_1.default)(newDefinition);
    // This conditional (and breaking change) was introduced to help us move from
    // legacy React classes to functional components & es6 classes which lack
    // `getDefaultProps`.
    if (newClass.getDefaultProps) {
        newClass.defaultProps = newClass.getDefaultProps();
        delete newClass.getDefaultProps;
    }
    return newClass;
}
exports.createClass = createClass;
/**
 * Return all elements matching the specified types
 */
function filterTypes(children, types) {
    if (types === undefined)
        return [];
    return lodash_1.default.filter(react_1.default.Children.toArray(children), function (element) {
        return react_1.default.isValidElement(element) &&
            lodash_1.default.includes(lodash_1.default.castArray(types), element.type);
    });
}
exports.filterTypes = filterTypes;
/**
 * Return all elements found in props and children of the specified types
 */
function findTypes(props, types) {
    if (types === undefined) {
        return [];
    }
    // get elements from props (using types.propName)
    var elementsFromProps = lodash_1.default.reduce(lodash_1.default.castArray(types), function (acc, type) {
        return lodash_1.default.isNil(type.propName)
            ? []
            : createElements(type, lodash_1.default.flatten(lodash_1.default.values(lodash_1.default.pick(props, type.propName))));
    }, []);
    if (props.children === undefined) {
        return elementsFromProps;
    }
    // return elements from props and elements from children
    return elementsFromProps.concat(filterTypes(props.children, types));
}
exports.findTypes = findTypes;
// return all elements found in props and children of the specified types
// export function findTypes<P2>(
// 	props: { children?: React.ReactNode },
// 	types?: TypesType<P2>
// ): React.ReactNode[] {
// 	if (types === undefined) {
// 		return [];
// 	}
// 	// get elements from props (using types.propName)
// 	const elementsFromProps: React.ReactNode[] = _.reduce(
// 		_.castArray<any>(types),
// 		(acc: React.ReactNode[], type): React.ReactNode[] => {
// 			return _.isNil(type.propName)
// 				? []
// 				: createElements(
// 						type,
// 						_.flatten(_.values(_.pick(props, type.propName)))
// 				  );
// 		},
// 		[]
// 	);
// 	if (props.children === undefined) {
// 		return elementsFromProps;
// 	}
// 	// return elements from props and elements from children
// 	return elementsFromProps.concat(filterTypes<P2>(props.children, types));
// }
/**
 * Return all elements not matching the specified types
 */
function rejectTypes(children, types) {
    types = [].concat(types); // coerce to Array
    return lodash_1.default.reject(react_1.default.Children.toArray(children), function (element) {
        return react_1.default.isValidElement(element) && lodash_1.default.includes(types, element.type);
    });
}
exports.rejectTypes = rejectTypes;
/**
 * Return an array of elements (of the given type) for each of the values
 */
function createElements(type, values) {
    if (values === void 0) { values = []; }
    return lodash_1.default.reduce(values, function (elements, typeValue) {
        if (react_1.default.isValidElement(typeValue) && typeValue.type === type) {
            return elements.concat(typeValue);
        }
        else if ((0, state_management_1.isPlainObjectOrEsModule)(typeValue) &&
            !react_1.default.isValidElement(typeValue)) {
            return elements.concat(react_1.default.createElement(type, typeValue));
        }
        else if (lodash_1.default.isUndefined(typeValue)) {
            return elements;
        }
        else {
            return elements.concat(react_1.default.createElement(type, null, typeValue));
        }
    }, []);
}
exports.createElements = createElements;
/**
 * Return the first element found in props and children of the specificed type(s)
 */
function getFirst(props, types, defaultValue) {
    return lodash_1.default.first(findTypes(props, types)) || defaultValue;
}
exports.getFirst = getFirst;
/**
 *  Adds any speicial omitted props to an array
 * @param {string[]} componentProps - an array of the component's props
 * @param {boolean} targetIsDOMElement - true by default; specifies if the top-level element of the component is a plain DOM Element or a React Component Element
 * @return {string[]} the array of component props plus the additional omitted keys
 * */
function addSpecialOmittedProps(componentProps, targetIsDOMElement) {
    if (componentProps === void 0) { componentProps = []; }
    if (targetIsDOMElement === void 0) { targetIsDOMElement = true; }
    // We only want to exclude the `callbackId` key when we're omitting props
    // destined for a DOM element.
    // We always want to add the `initialState` key
    // to the list of excluded props.
    var additionalOmittedKeys = targetIsDOMElement
        ? ['initialState', 'callbackId']
        : ['initialState'];
    return componentProps.concat(additionalOmittedKeys);
}
exports.addSpecialOmittedProps = addSpecialOmittedProps;
/**
 * Deprecated from lucid-ui  May 25, 2022 by Noah Yasskin
 * Do not use this method because
 * the import PropTypes from 'prop-types' stopped working as desired
 * component.propTypes does not compile correctly
 * and props in the passThroughs object leak through
 * because they are not being omitted.
 */
// Omit props defined in propTypes of the given type and any extra keys given
// in third argument
//
// We also have a "magic" prop called `callbackId`.
// It can be used to identify a component in a list
// without having to create extra closures.
//
// It is always excluded from a DOM elements
//
// Note: The Partial<P> type is referring to the props passed into the omitProps,
// not the props defined on the component.
function omitProps(props, component, keys, targetIsDOMElement) {
    if (keys === void 0) { keys = []; }
    if (targetIsDOMElement === void 0) { targetIsDOMElement = true; }
    // We only want to exclude the `callbackId` key when we're omitting props
    // destined for a DOM element.
    // We always want to exclude the `initialState` key.
    var additionalOmittedKeys = targetIsDOMElement
        ? ['initialState', 'callbackId']
        : ['initialState'];
    // this is to support non-createClass components that we've converted to TypeScript
    if (component === undefined) {
        return lodash_1.default.omit(props, keys.concat(additionalOmittedKeys));
    }
    return lodash_1.default.omit(props, lodash_1.default.keys(component.propTypes).concat(keys).concat(additionalOmittedKeys));
}
exports.omitProps = omitProps;
//# sourceMappingURL=component-types.js.map