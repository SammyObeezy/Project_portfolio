"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shiftChildren = exports.sharesAncestor = exports.dispatchDOMEvent = exports.scrollParentTo = exports.getAbsoluteBoundingClientRect = void 0;
var lodash_1 = __importDefault(require("lodash"));
function getAbsoluteBoundingClientRect(domNode) {
    if (!domNode) {
        throw new Error('getAbsoluteBoundingClientRect called without a domNode');
    }
    var elementRect = domNode && domNode.getBoundingClientRect();
    return {
        bottom: elementRect.bottom + window.pageYOffset,
        top: elementRect.top + window.pageYOffset,
        left: elementRect.left + window.pageXOffset,
        right: elementRect.right + window.pageXOffset,
        height: elementRect.height,
        width: elementRect.width,
    };
}
exports.getAbsoluteBoundingClientRect = getAbsoluteBoundingClientRect;
function scrollParentTo(domNode, additionalOffset) {
    if (additionalOffset === void 0) { additionalOffset = 0; }
    if (domNode) {
        var parentElement = domNode.parentElement;
        if (parentElement) {
            if (parentElement.scrollTop > domNode.offsetTop - additionalOffset) {
                // if the top of the node is above the scroll line,
                // align to top
                parentElement.scrollTop = domNode.offsetTop - additionalOffset;
            }
            else if (parentElement.scrollTop + parentElement.clientHeight <
                domNode.offsetTop + domNode.offsetHeight) {
                // else if the bottom of the node is below the fold,
                // align to bottom
                parentElement.scrollTop =
                    domNode.offsetHeight -
                        (parentElement.clientHeight - domNode.offsetTop);
            } // else don't need to align anything
        }
    }
}
exports.scrollParentTo = scrollParentTo;
function dispatchDOMEvent(node, eventName, assignedEventProps) {
    var event = document.createEvent('Event');
    event.initEvent(eventName, true, true);
    node.dispatchEvent(lodash_1.default.assign(event, assignedEventProps));
    return event;
}
exports.dispatchDOMEvent = dispatchDOMEvent;
/**
 * sharesAncestor
 *
 * Recursively looks at `node` and its parents for `nodeName` and makes
 * sure it contains `siblingNode`.
 *
 * @param {Node} node - dom node to check if any of its ancestors are a `<label>`
 * @param {Node} siblingNode - dom node to see if it shares an ancestor
 * @param {string} nodeName - dom node name, should be uppercased, e.g. `LABEL` or `SPAN`
 * @returns {boolean}
 */
function sharesAncestor(node, siblingNode, nodeName) {
    var currentNodeName = lodash_1.default.get(node, 'nodeName');
    var parentElement = lodash_1.default.get(node, 'parentElement');
    if (currentNodeName === nodeName) {
        return node.contains(siblingNode);
    }
    if (parentElement) {
        return sharesAncestor(parentElement, siblingNode, nodeName);
    }
    return false;
}
exports.sharesAncestor = sharesAncestor;
function shiftChildren(parent, n) {
    if (n === void 0) { n = 1; }
    if (n < 0) {
        lodash_1.default.times(Math.abs(n), function () {
            parent.appendChild(parent.children[0]);
        });
    }
    else if (n > 0) {
        lodash_1.default.times(n, function () {
            parent.insertBefore(parent.children[parent.children.length - 1], parent.children[0]);
        });
    }
}
exports.shiftChildren = shiftChildren;
//# sourceMappingURL=dom-helpers.js.map